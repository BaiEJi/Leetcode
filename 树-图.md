



## [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724101928625.png" alt="image-20230724101928625" style="zoom:67%;" />

> 将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。
>
> > 就是通过谦虚遍历展开呗
> >
> > - 递归
> > - 栈
> > - mirrors

```go
func flatten(root *TreeNode) {
	list := preorderTraversal(root)
	for i := 1; i < len(list); i++ {
		prev, curr := list[i-1], list[i]
		prev.Left, prev.Right = nil, curr
	}
}

func preorderTraversal(root *TreeNode) []*TreeNode {
	list := []*TreeNode{}
	if root != nil {
		list = append(list, root)
		list = append(list, preorderTraversal(root.Left)...)
		list = append(list, preorderTraversal(root.Right)...)
	}
	return list
}
```





## [100. 相同的树](https://leetcode.cn/problems/same-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230722144745334.png" alt="image-20230722144745334" style="zoom:67%;" />

> 递归, easy 666666

```go
func isSameTree(p *TreeNode, q *TreeNode) bool {
	if p == nil && q == nil {
		return true
	}
	if p == nil || q == nil {
		return false
	}
	return p.Val == q.Val && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
```

## [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230723004721906.png" alt="image-20230723004721906" style="zoom:67%;" />

> 看到BST, 一定要直接想到中序遍历呀!!!!!!!!!!!!
>
> 这两个基本上就是一致的, 尤其是在判定有序的时候
>
> // 交换的是节点的值

### 显式中序遍历

> 。对于二叉搜索树，我们知道如果对其进行中序遍历，得到的值序列是递增有序的，而如果我们错误地交换了两个节点，等价于在这个值序列中交换了两个值，破坏了值序列的递增性。
>
> 1. 找到二叉搜索树中序遍历得到值序列的不满足条件的位置。
> 2. 如果有两个, 交换即可
> 3. 如果有一个, i和i+1交换
> 4. 这个find真的很666呀 牛皮 先按照有一个去找, 找到第二个再把第一个修改
> 5. 通过递归去交换

```go
func recoverTree(root *TreeNode) {
	nums := []int{}

	// 既可以遍历, 也可以在便利的时候修改
	var inorder func(node *TreeNode, change bool, x, y int)
	inorder = func(node *TreeNode, change bool, x, y int) {
		if node == nil {
			return
		}
		if !change {
			inorder(node.Left, false, 0, 0)
			nums = append(nums, node.Val)
			inorder(node.Right, false, 0, 0)
		} else {
			inorder(node.Left, true, x, y)
			if node.Val == x {
				node.Val = y
			} else if node.Val == y {
				node.Val = x
			}
			inorder(node.Right, true, x, y)
		}

	}
	// 遍历存放nums
	inorder(root, false, 0, 0)

	// 找到 x 与 y
	index1, index2 := -1, -1
	for i := 0; i < len(nums)-1; i++ {
		if nums[i+1] < nums[i] {
			index2 = i + 1
			if index1 == -1 {
				index1 = i
			} else {
				break
			}
		}
	}

	inorder(root, true, nums[index1], nums[index2])
}
```



### 隐式中序遍历

> 由于我们只关心中序遍历的值序列中每个相邻的位置的大小关系是否满足条件，且错误交换后最多两个位置不满足条件，因此在中序遍历的过程我们只需要维护当前中序遍历到的最后一个节点 pred，然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。
>
> 这样我们就可以在中序遍历中直接找到被错误交换的两个节点 x 和 y，不用显式建立 \nums 数组。

```go
func recoverTree(root *TreeNode) {
	stack := []*TreeNode{}
	var x, y, pred *TreeNode
	for len(stack) > 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		// 就是在一次循环里面, 扮演了上次的角色
		// 在非递归便利的同时, 获取了idx1, 和 idx2
		// 多记录了一个prev
		if pred != nil && root.Val < pred.Val {
			y = root
			if x == nil {
				x = pred
			} else {
				break
			}
		}
		pred = root
		root = root.Right
	}
	x.Val, y.Val = y.Val, x.Val
}
```



### mirros遍历



## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230723223325877.png" alt="image-20230723223325877" style="zoom:67%;" />

> - 一般来说, 二叉树的终止条件都是nil, 这样写更方便
> - 需要单根的就从root开始, 双根就左右儿子开始
>
> 队列方法 很good
>
> - 首先从队列中拿出两个节点(`left` 和 `right`)比较
> - 将 left 的 left 节点和 right 的 right 节点放入队列
>   将 left 的 right 节点和 right 的 left 节点放入队列
>   时间复杂度是 O(n)，空间复杂度是 O(n)
> - 每次入队都是首尾, 首尾, 所以这样直接取前两个比较久ok

```go
func isSymmetric(root *TreeNode) bool {
	var f func(p *TreeNode, q *TreeNode) bool
	f = func(p *TreeNode, q *TreeNode) bool {
		if p == nil && q == nil {
			return true
		}
		if p == nil || q == nil {
			return false
		}
		return p.Val == q.Val && f(p.Left, q.Right) && f(p.Right, q.Left)
	}
	if root == nil {
		return true
	}
	return f(root.Left, root.Right)
}
```









## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230723231343956.png" alt="image-20230723231343956" style="zoom:67%;" />

> 直接层序遍历就ok
>
> 也可以递归求解

```go
// 层序遍历
func maxDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	res := 0
	queue := []*TreeNode{root}

	for len(queue) != 0 {
		res += 1
		l := len(queue)
		for i := 0; i < l; i++ {
			node := queue[0]
			queue = queue[1:]
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
	}
	return res
}
```

```go
// 递归
func maxDepth(root *TreeNode) int {
	var f func(root *TreeNode) int
	f = func(root *TreeNode) int {
		if root == nil {
			return 0
		}
		return max(f(root.Left), f(root.Right)) + 1
	}
	return f(root)
}
```

## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724004902012.png" alt="image-20230724004902012" style="zoom:67%;" />

> 递归
>
> - 返回条件 nil
> - 返回值 深度(如果不满足, 则返回-1)
> - 不需要判断是BST(多虑了)

```go
func isBalanced(root *TreeNode) bool {
	var f func(root *TreeNode) int
	f = func(root *TreeNode) int {
		if root == nil {
			return 0
		}
		left, right := f(root.Left), f(root.Right)
		if left == -1 || right == -1 || abs(left-right) > 1 {
			return -1
		}
		return max(left, right) + 1
	}

	if f(root) == -1 {
		return false
	}
	return true
}
```

## [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724094348868.png" alt="image-20230724094348868" style="zoom:67%;" />

> 层序遍历第一个出现nil的就可以啦
>
> 也可以递归实现啊

```go
func minDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}

	var f func(root *TreeNode) int
	f = func(root *TreeNode) int {
		if root == nil {
			return math.MaxInt // 只有一个儿子返回一个大值
		}
		if root.Left == nil && root.Right == nil {
			return 1 // 真正的叶子才有高度
		}
		return min(f(root.Left), f(root.Right)) + 1
	}

	return f(root)
}
```

## [112. 路径总和](https://leetcode.cn/problems/path-sum/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724100122607.png" alt="image-20230724100122607" style="zoom:67%;" />

> 递归 ok
>
> 层序遍历, 保存(节点, 当前target), 就ok
>
> 自己的递归有毛病
>
> - 以0作为初始值传入, 向下遍历, 把和加上来, 对于target就是0会判断错误
> - 而且这样写边界条件太多
> - 题目中问的是到根节点
>
> 题解的递归
>
> - 

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
	if root == nil {
		return false
	}

	var f func(root *TreeNode, currentSum int) bool
	f = func(root *TreeNode, currentSum int) bool {
        // 必须是椰子节点, 和相等才可以
        // 到叶子结点才判断
		if currentSum == targetSum && root.Left == nil && root.Right == nil {
			return true
		}
		res := false
		if root.Left != nil {
			res = res || f(root.Left, currentSum+root.Left.Val)
		}
		if root.Right != nil {
			res = res || f(root.Right, currentSum+root.Right.Val)
		}
		return res
	}

	return f(root, root.Val)
}
```

```go
// 直接向叶子结点递归, 真的秒啊
// 我怎么就想不到呢
func hasPathSum(root *TreeNode, sum int) bool {
	if root == nil {
		return false
	}
	if root.Left == nil && root.Right == nil {
		return sum == root.Val
	}
	return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)
}
```

## [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724112809937.png" alt="image-20230724112809937" style="zoom:67%;" />

> 递归呗, 就是正常的回溯, 入栈出栈, dfs
>
> 递归二叉树多了, 正经的回溯还不会写了?

```go
func pathSum(root *TreeNode, targetSum int) [][]int {
	var res [][]int
	var tmpRes []int

	if root == nil {
		return res
	}

	var dfs func(root *TreeNode, currSum int)
	dfs = func(root *TreeNode, currSum int) {
		if root.Left == nil && root.Right == nil && currSum == targetSum {
			tmpRes = append(tmpRes, root.Val)
			res = append(res, append([]int(nil), tmpRes...))
			tmpRes = tmpRes[:len(tmpRes)-1]
			return
		}
		if root.Right == nil && root.Left == nil {
			return
		}

		tmpRes = append(tmpRes, root.Val)
		if root.Left != nil {
			dfs(root.Left, currSum+root.Left.Val)
		}
		if root.Right != nil {
			dfs(root.Right, currSum+root.Right.Val)
		}
		tmpRes = tmpRes[:len(tmpRes)-1]
	}

	dfs(root, root.Val)
	return res
}
```

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724115912217.png" alt="image-20230724115912217" style="zoom:67%;" />

> 这是一个完美二叉树
>
> 可以记录层数这样需要两个节点的数组就ok了, 这样是on, 不对

> 也就是说当我们要串联第 i 层节点时，需要先完成第 i-1 层的节点串联
> 第一层最多只有一个节点，不需要串联
> 第二层最多只有两个节点，借助根节点就可以完成串联了
> 第三层串联时，上一层已经串联完了，所以第三层可以完成串联
> 同理，可以完成第四层，第五层，第N层的串联

```go
func connect(root *Node) *Node {
	if root == nil {
		return nil
	}

	// pre
    // pre向下, tmp向右的
	pre := root
	for pre.Left != nil {
		tmp := pre
		for tmp != nil {
			tmp.Left.Next = tmp.Right
			if tmp.Next != nil {
				tmp.Right.Next = tmp.Next.Left
			}
			tmp = tmp.Next
		}
		pre = pre.Left
	}
	return root
}
```

## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724122316120.png" alt="image-20230724122316120" style="zoom:67%;" />

> go
>
> 每一行通过一个dummy串联起来
>
> 然后再去遍历下一, 牛蛙

```go
func connect(root *Node) *Node {
	if root == nil {
		return nil
	}

	cur := root
	for cur != nil {
		dummy := &Node{}
		pre := dummy

		for cur != nil {
			if cur.Left != nil {
				pre.Next = cur.Left
				pre = pre.Next
			}
			if cur.Right != nil {
				pre.Next = cur.Right
				pre = pre.Next
			}
			cur = cur.Next
		}
		cur = dummy.Next
	}
	return root
}
```

## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724234814030.png" alt="image-20230724234814030" style="zoom:67%;" />

> 递归呗

```go
func maxPathSum(root *TreeNode) int {
	res := math.MinInt
	var dfs func(root *TreeNode) int
	dfs = func(root *TreeNode) int {
		if root == nil {
			return 0
		}
		l, r := dfs(root.Left), dfs(root.Right)
		// 节点最高是这个root
		res = max(res, l+r+root.Val)
		// 返回的话, 最高不是root, 所以只能返回单边
		return max(0, max(l, r)+root.Val)
	}
	dfs(root)
	return res
}
```







## [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724162603712.png" alt="image-20230724162603712" style="zoom:67%;" />

> 递归, 层序都可以的

```go

func sumNumbers(root *TreeNode) int {
	if root == nil {
		return 0
	}

	res := 0
	var f func(root *TreeNode, currSum int)
	f = func(root *TreeNode, currSum int) {
		if root.Left == nil && root.Right == nil {
			res += currSum
			return
		}
		if root.Left != nil {
			f(root.Left, currSum*10+root.Left.Val)
		}
		if root.Right != nil {
			f(root.Right, currSum*1+root.Right.Val)
		}

	}
	f(root, root.Val)
	return res
}
```



## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230726120724788.png" alt="image-20230726120724788" style="zoom:67%;" />

> - 层序遍历, 只保护最右边的, 就是BFS

```go
func rightSideView(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	res := make([]int, 0)
	queue := []*TreeNode{root}
	for len(queue) != 0 {
		res = append(res, queue[len(queue)-1].Val)
		l := len(queue)
		for i := 0; i < l; i++ {
			tmp := queue[0]
			queue = queue[1:]
			if tmp.Left != nil {
				queue = append(queue, tmp.Left)
			}
			if tmp.Right != nil {
				queue = append(queue, tmp.Right)
			}
		}
	}
	return res
}
```

> DFS也可以, 就是记录当前的层数呗

```go
func rightSideView(root *TreeNode) []int {
	res := make([]int, 0)

	var dfs func(root *TreeNode, layer int)
	dfs = func(root *TreeNode, layer int) {
		if root == nil {
			return
		}
		if layer > len(res) {
			res = append(res, root.Val)
		}
		dfs(root.Right, layer+1)
		dfs(root.Left, layer+1)
	}

	dfs(root, 1)
	return res
}
```



## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230803172442521.png" alt="image-20230803172442521" style="zoom:67%;" />

```go
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	// 注意不这么写 要使用tmp变量啊
	root.Left, root.Right = invertTree(root.Right),invertTree(root.Left)
	return root
}
```



## [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230804102540009.png" alt="image-20230804102540009" style="zoom:67%;" />

> 这个也能递归, 很秀啊
>
> - 比直接递归求个数要更好
> - 至少每次都有一个子树可以直接求出

```go
func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	leftCnt, rightCnt := 0, 0
	left, right := root, root

	for left != nil {
		leftCnt++
		left = left.Left
	}

	for right != nil {
		rightCnt++
		right = right.Right
	}

	if leftCnt == rightCnt {
		return (1 << leftCnt) - 1
	} else {
		return 1 + countNodes(root.Left) + countNodes(root.Right)
	}
}
```



## [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807105037616.png" alt="image-20230807105037616" style="zoom:67%;" />

> dfs, Good
>
> - 深度优先搜索, 很简单
> - 广度优先搜索, 也是很棒的

```go
func binaryTreePaths(root *TreeNode) []string {
	if root == nil {
		return nil
	}
	res := []string{}
	var dfs func(root *TreeNode, s string)
	dfs = func(root *TreeNode, s string) {
		if root.Left == nil && root.Right == nil {
			res = append(res, s+strconv.Itoa(root.Val))
			return
		}
		if root.Left != nil {
			dfs(root.Left, s+strconv.Itoa(root.Val)+"->")
		}
		if root.Right != nil {
			dfs(root.Right, s+strconv.Itoa(root.Val)+"->")
		}
	}
	dfs(root, "")
	return res
}
```





## [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807105812831.png" alt="image-20230807105812831" style="zoom:67%;" />

> 在便利的时候, 使用一个bool值来判断是不是左节点

```go
func sumOfLeftLeaves(root *TreeNode) int {
	res := 0
	if root == nil {
		return 0
	}
	var dfs func(root *TreeNode, isLeft bool)
	dfs = func(root *TreeNode, isLeft bool) {
		if root == nil {
			return
		}
		if root.Left == nil && root.Right == nil {
			if isLeft {
				res += root.Val
			}
		}
		dfs(root.Left, true)
		dfs(root.Right, false)
	}
	dfs(root, false)
	return res
}
```

## [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807110942932.png" alt="image-20230807110942932" style="zoom:67%;" />

> 层序遍历最左边可以的
>
> dfs
>
> - 每次都先遍历左边的, 这样就是相同的层, 只保留最左边的
> - 便利顺序决定了结果的顺序



## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807111512738.png" alt="image-20230807111512738" style="zoom:67%;" />

> 在安排选择摄像头的位置的时候，**我们要从底向上进行推导，因为尽量让叶子节点的父节点安装摄像头，这样摄像头的数量才是最少的** ，这也是本道贪心的原理所在！
>
> 如何从低向上推导呢？
>
> 就是后序遍历也就是左右中的顺序，这样就可以从下到上进行推导了。
>
> 确定了遍历顺序，再看看这个状态应该如何转移，先来看看每个节点可能有几种状态：
> 我们分别有三个数字来表示：
>
> 0：该节点无覆盖
> 1：本节点有摄像头
> 2：本节点有覆盖
>
> 回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。
>
> 那么空节点不能是无覆盖的状态，这样叶子节点就可以放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。
>
> 所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了
>

```go
func minCameraCover(root *TreeNode) int {
	res := 0
	//0：该节点无覆盖
	//1：本节点有摄像头
	//2：本节点有覆盖
	var dfs func(root *TreeNode) int
	dfs = func(root *TreeNode) int {
		// 空节点是有覆盖的, 所以叶子结点不必放
		if root == nil {
			return 2
		}
		left, right := dfs(root.Left), dfs(root.Right)

		// 情况1
		// 左右节点都有覆盖
		if left == 2 && right == 2 {
			return 0
		}

		// 情况2
		// left == 0 && right == 0 左右节点无覆盖
		// left == 1 && right == 0 左节点有摄像头，右节点无覆盖
		// left == 0 && right == 1 左节点有无覆盖，右节点摄像头
		// left == 0 && right == 2 左节点无覆盖，右节点覆盖
		// left == 2 && right == 0 左节点覆盖，右节点无覆盖
		if left == 0 || right == 0 {
			res++
			return 1
		}
		// 情况3
		// left == 1 && right == 2 左节点有摄像头，右节点有覆盖
		// left == 2 && right == 1 左节点有覆盖，右节点有摄像头
		// left == 1 && right == 1 左右节点都有摄像头
		if left == 1 || right == 1 {
			return 2
		}
		return -1 // 不会走到这里
	}
	if dfs(root) == 0 {
		res += 1 // root 没有被覆盖
	}
	return res
}
```



## [2458. 移除子树后的二叉树高度](https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807121126576.png" alt="image-20230807121126576" style="zoom:67%;" />

> 最简单的方法, 就是直接遍历呗, 每个都遍历一次
>
> - 多次的dfs, 每次得到一点新的信息
> - 节点的值是1-n不同的
>
> <img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230807122527587.png" alt="image-20230807122527587" style="zoom:67%;" />



```go
func treeQueries(root *TreeNode, queries []int) []int {
	// 每棵子树的高度
	// 是子树的高度, 而不是到顶点的
	height := map[*TreeNode]int{}
	var getHeight func(*TreeNode) int
	getHeight = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		height[node] = 1 + max(getHeight(node.Left), getHeight(node.Right))
		return height[node]
	}
	getHeight(root)

	res := make([]int, len(height)+1) // 每个节点的答案
	var dfs func(*TreeNode, int, int)
	dfs = func(node *TreeNode, depth, restH int) {
		if node == nil {
			return
		}
		res[node.Val] = restH
		dfs(node.Left, depth+1, max(restH, depth+height[node.Right]))
		dfs(node.Right, depth+1, max(restH, depth+height[node.Left]))
	}
	dfs(root, 0, 0)

	for i, q := range queries {
		queries[i] = res[q]
	}
	return queries
}

```

## [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230830160927549.png" alt="image-20230830160927549" style="zoom: 67%;" />

> 向下传递最大和最小

```go
func maxAncestorDiff(root *TreeNode) int {
	res := 0
	var dfs func(root *TreeNode, min, max int)
	dfs = func(root *TreeNode, min, max int) {
		if root == nil {
			return
		}
		if root.Val < min {
			min = root.Val
		}
		if root.Val > max {
			max = root.Val
		}
		if max-min > res {
			res = max - min
		}
		dfs(root.Left, min, max)
		dfs(root.Right, min, max)
	}
	dfs(root,root.Val,root.Val)
	return res
}
```











# 遍历

## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230722145806430.png" alt="image-20230722145806430" style="zoom:67%;" />

> 递归变了so esay

```go
// 递归要写一个辅助函数的哈哈哈
func inorderTraversal(root *TreeNode) []int {
	res := make([]int, 0)
	var inOrder func(root *TreeNode)
	inOrder = func(root *TreeNode) {
		if root == nil {
			return
		}
		inOrder(root.Left)
		res = append(res, root.Val)
		inOrder(root.Right)
	}
	inOrder(root)
	return res
}
```

> 使用栈的方法
>
> - 一直向左放入栈
> - 弹出取值, 转向右儿子

```go
func inorderTraversal(root *TreeNode) []int {
	stack := make([]*TreeNode, 0)
	res := make([]int, 0)
	cur := root

	for cur != nil || len(stack) != 0 {
		if cur != nil {
            // 一直向左存放
			stack = append(stack, cur)
			cur = cur.Left
		} else {
            // 读取一个, 然后指向右儿子
			cur = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			res = append(res, cur.Val)
			cur = cur.Right
		}
	}
	return res
}
```



## [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

> 递归

```go
func preorderTraversal(root *TreeNode) []int {
	res := make([]int, 0)
	var preOrder func(root *TreeNode)
	preOrder = func(root *TreeNode) {
		if root == nil {
			return
		}
        res = append(res, root.Val)
		preOrder(root.Left)
		preOrder(root.Right)
	}
	preOrder(root)
	return res
}
```

> 迭代  这个是栈!!!!!!!!!!
>
> 前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。
>
> 什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

```go
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return []int{}
	}

	res := make([]int, 0)
	stack := []*TreeNode{root}
	for len(stack) != 0 {
		cur := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = append(res, cur.Val)
		if cur.Right != nil {
			stack = append(stack, cur.Right)
		}
		if cur.Left != nil {
			stack = append(stack, cur.Left)
		}
	}
	return res
}
```



## [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

> 递归

```go
func postorderTraversal(root *TreeNode) []int {
	res := make([]int, 0)
	var postOrder func(root *TreeNode)
	postOrder = func(root *TreeNode) {
		if root == nil {
			return
		}
		postOrder(root.Left)
		postOrder(root.Right)
        res = append(res, root.Val)
	}
	postOrder(root)
	return res
}
```

> 先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了 Good

```go
func postorderTraversal(root *TreeNode) []int {
	if root == nil {
		return []int{}
	}
	res := make([]int, 0)
	stack := []*TreeNode{root}
	for len(stack) != 0 {
		cur := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = append(res, cur.Val)
		if cur.Left != nil {
			stack = append(stack, cur.Left)
		}
		if cur.Right != nil {
			stack = append(stack, cur.Right)
		}

	}
	for i := 0; i < len(res)/2; i++ {
		res[i], res[len(res)-i-1] = res[len(res)-i-1], res[i]
	}
	return res
}
```



## ---统一迭代遍历

> **我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**
>
> **就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记**
>
> 可以用List模拟栈的哈, 666
>
> 可以由代码看出, 每个都是二次处理的
>
> 每次访问到一个节点, 都是在后面加入nil代表他需要处理
>
> 只是入栈顺序不同罢了

```go
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New() //栈
	res := []int{}         //结果集
	stack.PushBack(root)

	var node *TreeNode
	for stack.Len() > 0 {
		e := stack.Back()
		stack.Remove(e)     //弹出元素
		if e.Value == nil { // 如果为空，则表明是需要处理中间节点
			e = stack.Back() //弹出元素（即中间节点）
			stack.Remove(e)  //删除中间节点
			node = e.Value.(*TreeNode)
			res = append(res, node.Val) //将中间节点加入到结果集中
			continue                    //继续弹出栈中下一个节点
		}
		node = e.Value.(*TreeNode)
		//压栈顺序：右左中
		if node.Right != nil {
			stack.PushBack(node.Right)
		}
		if node.Left != nil {
			stack.PushBack(node.Left)
		}
		stack.PushBack(node) //中间节点压栈后再压入nil作为中间节点的标志符
		stack.PushBack(nil)
	}
	return res
}
```

```go
func postorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New() //栈
	res := []int{}         //结果集
	stack.PushBack(root)
	var node *TreeNode
	for stack.Len() > 0 {
		e := stack.Back()
		stack.Remove(e)
		if e.Value == nil { // 如果为空，则表明是需要处理中间节点
			e = stack.Back() //弹出元素（即中间节点）
			stack.Remove(e)  //删除中间节点
			node = e.Value.(*TreeNode)
			res = append(res, node.Val) //将中间节点加入到结果集中
			continue                    //继续弹出栈中下一个节点
		}
		node = e.Value.(*TreeNode)
		//压栈顺序：中右左
		stack.PushBack(node) //中间节点压栈后再压入nil作为中间节点的标志符
		stack.PushBack(nil)
		if node.Right != nil {
			stack.PushBack(node.Right)
		}
		if node.Left != nil {
			stack.PushBack(node.Left)
		}
	}
	return res
}
```

```go
func inorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	stack := list.New()
	res := []int{}
	stack.PushFront(root)
	var node *TreeNode

	for stack.Len() > 0 {
		e := stack.Back()
		stack.Remove(e)
		if e.Value == nil {
			e = stack.Back()
			stack.Remove(e)
			node = e.Value.(*TreeNode)
			res = append(res, node.Val)
			continue
		}
		node = e.Value.(*TreeNode)
		if node.Right != nil {
			stack.PushBack(node.Right)
		}
		stack.PushBack(node)
		stack.PushBack(nil)
		if node.Left != nil {
			stack.PushBack(node.Left)
		}
	}
	return res
}
```



## [102. 层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230723220738676.png" alt="image-20230723220738676" style="zoom:67%;" />

> BFS Queue ok
>
> - 模板必须记住, 自己卡了一下

```go
func levelOrder(root *TreeNode) [][]int {
	res := make([][]int, 0)
	if root == nil {
		return res
	}

	queue := make([]*TreeNode, 0)
	queue = append(queue, root)

	for len(queue) != 0 {
		tmpRes := make([]int, 0)
		l := len(queue)
		for i := 0; i < l; i++ {
			node := queue[0]
			tmpRes = append(tmpRes, node.Val)
			queue = queue[1:]
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		res = append(res, tmpRes)
	}
	return res
}
```

## [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724002236830.png" alt="image-20230724002236830" style="zoom:67%;" />

> 就是层序遍历呗

```go
func zigzagLevelOrder(root *TreeNode) [][]int {
	var res [][]int
	if root == nil {
		return res
	}
	
	var list []*TreeNode
	list = append(list, root)
	var layer, cnt = 0, 1
	var next  = true

	for next {
		next = false
		cntTmp := 0
		res = append(res, []int{})
		for i := 0; i < cnt; i++ {
			t := list[0]
			list = list[1:]
			if layer%2 == 0 {
				res[layer] = append(res[layer], t.Val)
			} else {
				res[layer] = append(res[layer], t.Val)
				copy(res[layer][1:], res[layer])
				res[layer][0] = t.Val
			}
			
			if t.Left != nil {
				list = append(list, t.Left)
				cntTmp += 1
				next = true
			}
			if t.Right != nil {
				list = append(list, t.Right)
				cntTmp += 1
				next = true
			}
		}
		cnt = cntTmp
		layer += 1
	}
	return res
}
```



## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230723232443335.png" alt="image-20230723232443335" style="zoom:67%;" />

> 不就是层序遍历的结果加一个翻转吗,....

```go
func zigzagLevelOrder(root *TreeNode) [][]int {
	res := make([][]int, 0)
	if root == nil {
		return res
	}
	layer := 0
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)

	for len(queue) != 0 {
		tmpRes := make([]int, 0)
		l := len(queue)
		for i := 0; i < l; i++ {
			node := queue[0]
			tmpRes = append(tmpRes, node.Val)
			queue = queue[1:]
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		if layer%2 == 1 {
			for i := 0; i < len(tmpRes)/2; i++ {
				tmpRes[i], tmpRes[len(tmpRes)-i-1] = tmpRes[len(tmpRes)-i-1], tmpRes[i]
			}
		}
		res = append(res, tmpRes)
		layer += 1
	}
	return res
}
```

> 递归写法
>
> so easy

```go
func zigzagLevelOrder(root *TreeNode) [][]int {
	var res [][]int

	// layer1 对应res[0]
	var f func(root *TreeNode, layer int)
	f = func(root *TreeNode, layer int) {
		if root == nil {
			return
		}

		// 这层第一个元素
		if len(res) < layer {
			res = append(res, []int{})
		}

		// 正向加入
		if layer%2 == 1 {
			res[layer-1] = append(res[layer-1], root.Val)
		} else {
			res[layer-1] = append([]int{root.Val}, res[layer-1]...)
		}

		f(root.Left, layer+1)
		f(root.Right, layer+1)
	}
	f(root, 1)
	return res
}
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724142920568.png" alt="image-20230724142920568" style="zoom:67%;" />

> 嗯呢 中左右, 左中右
>
> 一直分就ok啦......

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
	// 递归终点
	if len(inorder) == 0 {
		return nil
	}

	root := &TreeNode{Val: preorder[0]}
	// 寻找idx在inorder中的位置
	idx := 0
	for ; inorder[idx] != root.Val; idx++ {
	}
	root.Left = buildTree(preorder[1:1+idx], inorder[:idx])
	root.Right = buildTree(preorder[1+idx:], inorder[idx+1:])
	return root
}
```

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724145328336.png" alt="image-20230724145328336" style="zoom:67%;" />

> Good

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
	if len(inorder) == 0 {
		return nil
	}
	root := &TreeNode{Val: postorder[len(postorder)-1]}
	idx := 0
	for ; inorder[idx] != root.Val; idx++ {
	}
	root.Left = buildTree(inorder[:idx], postorder[:idx])
	root.Right = buildTree(inorder[idx+1:], postorder[idx:len(postorder)-1])
	return root
}
```





## [847/87. 访问所有节点的最短路径](https://leetcode.cn/problems/shortest-path-visiting-all-nodes/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20231205105340703.png" alt="image-20231205105340703" style="zoom:80%;" />

#### 状态压缩 + BFS

因为是等权图，求从某个状态到另一状态的最短路，容易想到 `BFS`。

同时我们需要知道下一步能往哪些点进行移动，因此除了记录当前的点访问状态 `state` 以外，还需要记录最后一步是在哪个点 u，因此我们需要使用二元组进行记录 `(state,u)`，同时使用 `dist` 来记录到达 `(state,u)`使用的步长是多少。

> - 这是一个多源的bfs, 所有的顶点一起开始
> - ==bfs先到达的一定更优秀,因为水波纹扩散==

```go
func shortestPathLength(graph [][]int) int {
	n := len(graph) // 节点个数
	mask := 1 << n  // 最大有这么多种状态

	dist := make([][]int, mask)
	for i := 0; i < mask; i++ {
		dist[i] = make([]int, n)
		for j := 0; j < n; j++ {
			dist[i][j] = math.MaxInt32 
		}
	}

	// 因为可以从任意起点出发，先将起始的起点状态入队，并设起点距离为 0
	// (state, u) , u是当前状态的最后一个访问点
	deque := make([][]int, 0)
	for i := 0; i < n; i++ {
		dist[1<<i][i] = 0
		deque = append(deque, []int{1 << i, i})
	}

	for len(deque) != 0 {
		t := deque[0]
		deque = deque[1:]
		state, u := t[0], t[1]
		step := dist[state][u]
		if state == mask-1 {
			return step
		}
		for _, i := range graph[u] {
            // 往回走的时候, state是一样的, 但是i不一样, 确保往回走也最多走一次(不是最大值了,无法入队)
            // 同样的状态, 同样的来时路, 先来的一定是最优的
            // (状态, 来时路)来却定方案
            // 可以理解为多源并发的
            // 来时点这一引入保证了可以往回走, 但是只能走一次!!!!!!!!!!!!!
			if dist[state|(1<<i)][i] == math.MaxInt32 {
				dist[state|(1<<i)][i] = step + 1
				deque = append(deque, []int{state | (1 << i), i})
			}
		}
	}
	return -1
}
```



## [851/88. 喧闹和富有](https://leetcode.cn/problems/loud-and-rich/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20231206104509875.png" alt="image-20231206104509875" style="zoom: 80%;" />

> 其实就是比他有钱的人里面最安静的
>
> - 可以想象为dfs, dfs树的终点就是最有钱的人, 然后结果向上返回, 更新比他钱少的人.
> - 而且res可以直接作为visit访问数组来提前返回, 没必要再多写了
> - 想象每一颗树形结构就ok啦啦啦!!!!!!!!!!!

```go
func loudAndRich(richer [][]int, quiet []int) []int {
	graph := make(map[int][]int)
	res := make([]int, len(quiet))
	for i := 0; i < len(quiet); i++ {
		res[i] = -1
	}
	for i := 0; i < len(richer); i++ {
		graph[richer[i][1]] = append(graph[richer[i][1]], richer[i][0])
	}

	var dfs func(idx int)
	dfs = func(idx int) {
		if res[idx] != -1 {
			return
		}
		res[idx] = idx // 默认是自己
		for i := 0; i < len(graph[idx]); i++ {
			dfs(graph[idx][i]) // 搜索这个比他富有的人的结果
			if quiet[res[graph[idx][i]]] < quiet[res[idx]] {
				res[idx] = res[graph[idx][i]]
			}
		}
	}

	for i := 0; i < len(quiet); i++ {
		dfs(i)
	}
	return res
}
```















# BST



## [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230722150130377.png" alt="image-20230722150130377" style="zoom:67%;" />

> 递归呗, 不行的话, 就两个数组层序遍历就ok啦, 两个儿子不存在就存Nil
>
> 但是向下的时候必须传递这个节点的值才可以的
>
> - 自己想的太复杂了 fk
> - 什么爷爷的值, 父亲的右儿子啥的, 太复杂了
>
> 要的是
>
> - 记录遍历到当前节点的所有祖先中的最大值和最小值
> - 每个节点都会向左或者向右
> - 对于向下遍历到的某个节点
>   - 所有向左的 更新上界, 不能超过这个上界
>   - 向右的, 更新下界, 不能低于这个下界
>   - 也就是说, 对于一个节点, 所有祖先都对他的值进行了限制
>     - 有的是限制上界, 有的是限制下界
>
> 还有一种方法
>
> - 中序遍历是升序的 Good
> - bst和中序遍历是分不开的

```go
func isValidBST(root *TreeNode) bool {
	return helper(root, math.MinInt64, math.MaxInt64)
}

func helper(root *TreeNode, lower, upper int) bool {
	if root == nil {
		return true
	}
	if root.Val <= lower || root.Val >= upper {
		return false
	}
	return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
}
```



## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724102756837.png" alt="image-20230724102756837" style="zoom:67%;" />

> 二分查找, 递归实现呗, 直接以中间的作为根节点, 左右节点递归实现
>
> 还是挺简单的

```go
func sortedArrayToBST(nums []int) *TreeNode {
	var f func(lower, upper int) *TreeNode
	f = func(lower, upper int) *TreeNode {
		if lower > upper {
			return nil
		}
		idx := lower + (upper-lower)/2
		return &TreeNode{Val: nums[idx], Left: f(lower, idx-1), Right: f(idx+1, upper)}
	}
	return f(0, len(nums))
}
```

## [109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724103437259.png" alt="image-20230724103437259" style="zoom:67%;" />

> 可以读取所有的值, 然后转为上一道题../......

```go
func sortedListToBST(head *ListNode) *TreeNode {
	var nums []int
	for head != nil {
		nums = append(nums, head.Val)
		head = head.Next
	}
	var f func(lower, upper int) *TreeNode
	f = func(lower, upper int) *TreeNode {
		if lower > upper {
			return nil
		}
		idx := lower + (upper-lower)/2
		return &TreeNode{Val: nums[idx], Left: f(lower, idx-1), Right: f(idx+1, upper)}
	}
	return f(0, len(nums)-1)
}
```

> 直接用数组存储当然是可以的，但要额外O(n)的储存空间，我们不希望要这个空间，而希望直接再list上直接完成树的构建。
>
> 朴素的快慢指针，属于先序遍历，每次都要先用线性时间找到“中间结点”，这部分的复杂度是O(nlogn)。但其实，我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。

> 具体地，设当前链表的左端点为 left，右端点right，包含关系为「左闭右开」，即left 包含在链表中而 right 不包含在链表中。我们希望快速地找出链表的中位数节点mid。
>
> 为什么要设定「左闭右开」的关系？由于题目中给定的链表为单向链表，访问后继元素十分容易，但无法直接访问前驱元素。因此在找出链表的中位数节点 mid 之后，如果设定「左闭右开」的关系，我们就可以直接用 (left,mid) 以及 (mid.next,right) 来表示左右子树对应的列表了。并且，初始的列表也可以用 (head,null) 方便地进行表示，其中null 表示空节点。
>
> 找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针fast 和慢指针slow 均指向链表的左端点left。我们将快指针 fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。
>
> 时空复杂度都是 o(nlogn)

```go
func sortedListToBST(head *ListNode) *TreeNode {
	return buildTree(head, nil)
}

func getMedian(left, right *ListNode) *ListNode {
	fast, slow := left, left
	for fast != right && fast.Next != right {
		fast = fast.Next.Next
		slow = slow.Next
	}
	return slow
}

func buildTree(left, right *ListNode) *TreeNode{
	if left == right {
		return nil
	}
	mid := getMedian(left, right)
	root := &TreeNode{mid.Val, nil, nil}
	root.Left = buildTree(left, mid)
	root.Right = buildTree(mid.Next, right)
	return root
}
```

> 方法一的时间复杂度的瓶颈在于寻找中位数节点。由于**构造出的二叉搜索树的中序遍历结果就是链表本身**，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230724104920016.png" alt="image-20230724104920016" style="zoom:50%;" />

> 因为BST和终须是分不开的啊
>
> 时间 n 空间 logn

```go
func sortedListToBST(head *ListNode) *TreeNode {
	// // 获取长度
	length := 0
	t := head
	for ; t != nil; t = t.Next {
		length++
	}
	// 全局节点
	globalHead := head

	// 构建函数
	var buildTree func(left, right int) *TreeNode
	buildTree = func(left, right int) *TreeNode {
		if left > right {
			return nil
		}
		mid := left + (right-left)/2
        // 下面这个可是大坑啊
		//var root *TreeNode
		root := &TreeNode{}
		root.Left = buildTree(left, mid-1)
		// 此时global已经被更新了
		root.Val = globalHead.Val
		globalHead = globalHead.Next
		root.Right = buildTree(mid+1, right)
		return root
	}
	return buildTree(0, length-1)
}
```

## [173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230728010339416.png" alt="image-20230728010339416" style="zoom:67%;" />

> 啊????????????????? 就这
>
> - 中序遍历存入数组
> - 栈进行遍历 (这就是一个单调栈啊)(但是其实和单调栈没什么关系)\
>
> 其实就是遍历的改版

```go
type BSTIterator struct {
	arr []int
}

func Constructor(root *TreeNode) (it BSTIterator) {
	it.inorder(root)
	return
}

func (it *BSTIterator) inorder(node *TreeNode) {
	if node == nil {
		return
	}
	it.inorder(node.Left)
	it.arr = append(it.arr, node.Val)
	it.inorder(node.Right)
}

func (it *BSTIterator) Next() int {
	val := it.arr[0]
	it.arr = it.arr[1:]
	return val
}

func (it *BSTIterator) HasNext() bool {
	return len(it.arr) > 0
}
```

> 其实就是把迭代遍历给拆开啦

```go
type BSTIterator struct {
	stack []*TreeNode
	cur   *TreeNode
}

func Constructor(root *TreeNode) BSTIterator {
	return BSTIterator{cur: root}
}

func (it *BSTIterator) Next() int {
	for node := it.cur; node != nil; node = node.Left {
		it.stack = append(it.stack, node)
	}
	it.cur, it.stack = it.stack[len(it.stack)-1], it.stack[:len(it.stack)-1]
	val := it.cur.Val
	it.cur = it.cur.Right
	return val
}

func (it *BSTIterator) HasNext() bool {
	return it.cur != nil || len(it.stack) > 0
}
```

## [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230806112418715.png" alt="image-20230806112418715" style="zoom:67%;" />

> 中序遍历就ok啦

```go
func kthSmallest(root *TreeNode, k int) int {
	stack := []*TreeNode{}
	cur := root
	for cur != nil || len(stack) != 0 {
		if cur != nil {
			stack = append(stack, cur)
			cur = cur.Left
		} else {
			cur = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			k--
			if k == 0 {
				return cur.Val
			}
			cur = cur.Right
		}
	}
	return 0
}
```

> 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230806115826930.png" alt="image-20230806115826930" style="zoom:67%;" />

应该是会说就行啦







# 前缀树

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230802151104149.png" alt="image-20230802151104149" style="zoom:67%;" />

> bool 改成 int 就可以计数了

```go
type Trie struct {
	tries []*Trie
	end   []bool
}

func Constructor() Trie {
	// 第一层总得有吧
	return Trie{tries: make([]*Trie, 26), end: make([]bool, 26)}
}

func (this *Trie) Insert(word string) {
	now_trie := this
	for idx := 0; idx < len(word); idx++ {
		if now_trie.tries[word[idx]-'a'] == nil {
			now_trie.tries[word[idx]-'a'] = &Trie{tries: make([]*Trie, 26), end: make([]bool, 26)}
		}
		if idx == len(word)-1 {
			now_trie.end[word[idx]-'a'] = true
		} else {
			now_trie = now_trie.tries[word[idx]-'a']
		}
	}
}

func (this *Trie) Search(word string) bool {
	now_trie := this
	for idx := 0; idx < len(word); idx++ {
		if now_trie.tries[word[idx]-'a'] == nil {
			return false
		}
		if idx == len(word)-1 {
			if now_trie.end[word[idx]-'a'] == true {
				return true
			} else {
				return false
			}
		} else {
			now_trie = now_trie.tries[word[idx]-'a']
		}
	}
	return true
}

func (this *Trie) StartsWith(prefix string) bool {
	now_trie := this
	for idx := 0; idx < len(prefix); idx++ {
		if now_trie.tries[prefix[idx]-'a'] == nil {
			return false
		}
		now_trie = now_trie.tries[prefix[idx]-'a']
	}
	return true
}
```

> type TrieNode struct {
>     children [26]*TrieNode
>     isEnd    bool
> }
>
> 这种更省内存吗???
>
> 不是, 只是把是不是一个单词放在了上一层进行判断, 确实放在下一层判断的话更明显

```go
// 比我写的明白太多了

type Trie struct {
	children [26]*Trie
	isEnd    bool
}

func Constructor() Trie {
	return Trie{}
}

func (t *Trie) Insert(word string) {
	node := t
	for _, ch := range word {
		ch -= 'a'
		if node.children[ch] == nil {
			node.children[ch] = &Trie{}
		}
		node = node.children[ch]
	}
	node.isEnd = true
}

func (t *Trie) SearchPrefix(prefix string) *Trie {
	node := t
	for _, ch := range prefix {
		ch -= 'a'
		if node.children[ch] == nil {
			return nil
		}
		node = node.children[ch]
	}
	return node
}

func (t *Trie) Search(word string) bool {
	node := t.SearchPrefix(word)
	return node != nil && node.isEnd
}

func (t *Trie) StartsWith(prefix string) bool {
	return t.SearchPrefix(prefix) != nil
}
```





## [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230802213408296.png" alt="image-20230802213408296" style="zoom:67%;" />

> 省内存的方法
>
> type TrieNode struct {
>     children [26]*TrieNode
>     isEnd    bool
> }
>
> 而不是我这种写法
>
> 但是其实差不多啊

```go
type WordDictionary struct {
	tries []*WordDictionary
	end   []bool
}

func Constructor() WordDictionary {
	return WordDictionary{tries: make([]*WordDictionary, 26), end: make([]bool, 26)}
}

func (this *WordDictionary) AddWord(word string) {
	now_trie := this
	for idx := 0; idx < len(word); idx++ {
		if now_trie.tries[word[idx]-'a'] == nil {
			now_trie.tries[word[idx]-'a'] = &WordDictionary{tries: make([]*WordDictionary, 26), end: make([]bool, 26)}
		}
		if idx == len(word)-1 {
			now_trie.end[word[idx]-'a'] = true
		} else {
			now_trie = now_trie.tries[word[idx]-'a']
		}
	}
}

func (this *WordDictionary) Search(word string) bool {
	return help(this, word)
}

func help(now_trie *WordDictionary, word string) bool {
	if len(word) == 1 {
		if word[0] == '.' {
			for idx, next_trie := range now_trie.tries {
				if next_trie != nil && now_trie.end[idx] == true {
					return true
				}
			}
			return false
		} else {
			return now_trie.end[word[0]-'a'] == true
		}
	}

	if now_trie == nil || len(word) == 0 {
		return false // 递归终止
	}
	if word[0] == '.' {
		tmpRes := false
		for _, next_trie := range now_trie.tries {
			if next_trie != nil {
				tmpRes = tmpRes || help(next_trie, word[1:])
			}
		}
		return tmpRes
	} else { // 首个字母必须匹配
		if now_trie.tries[word[0]-'a'] == nil {
			return false
		} // 匹配了返回递归结果
		return help(now_trie.tries[word[0]-'a'], word[1:])
	}
}
```

```go
func help(nowNode *WordDictionary, word string) bool {
	if len(word) == 1 {
		if word[0] == '.' {
			for _, nextNode := range nowNode.children {
				if nextNode != nil && nextNode.isEnd {
					return true
				}
			}
			return false
		} else {
			if nowNode.children[word[0]-'a'] != nil {
				return nowNode.children[word[0]-'a'].isEnd
			}
			return false
		}
	}

	if nowNode == nil || len(word) == 0 {
		return false // 递归终止
	}
	if word[0] == '.' {
		tmpRes := false
		for _, nextNode := range nowNode.children {
			if nextNode != nil {
				tmpRes = tmpRes || help(nextNode, word[1:])
			}
		}
		return tmpRes
	} else { // 首个字母必须匹配
		if nowNode.children[word[0]-'a'] == nil {
			return false
		} // 匹配了返回递归结果
		return help(nowNode.children[word[0]-'a'], word[1:])
	}
}
```

## [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230802231126671.png" alt="image-20230802231126671" style="zoom:67%;" />

> 自然而然想到前缀树, 但是我写的太容易超时了
>
> 我认为超时在于参数传字符串这里, 拼接太多了
>
> 
>
> 使用buff快10倍

```go
func findWords(board [][]byte, words []string) []string {
	var res []string
	m, n := len(board), len(board[0])

	// 插入所有的word
	trie := &Trie{}
	for _, word := range words {
		trie.Insert(word)
	}

	var dfs func(trie *Trie, i int, j int, tmpStr string)
	dfs = func(trie *Trie, i int, j int, tmpStr string) {
		if i < 0 || j < 0 || i >= m || j >= n || board[i][j] == '#' || trie == nil {
			return
		}

		if trie.children[board[i][j]-'a'] != nil {
			if trie.children[board[i][j]-'a'].isEnd {
				res = append(res, tmpStr+string(board[i][j]))
				// 删除这个前缀树的单词
				trie.children[board[i][j]-'a'].isEnd = false
			}
			tmpChar := board[i][j]
			board[i][j] = '#'
			dfs(trie.children[tmpChar-'a'], i+1, j, tmpStr+string(tmpChar))
			dfs(trie.children[tmpChar-'a'], i-1, j, tmpStr+string(tmpChar))
			dfs(trie.children[tmpChar-'a'], i, j+1, tmpStr+string(tmpChar))
			dfs(trie.children[tmpChar-'a'], i, j-1, tmpStr+string(tmpChar))
			board[i][j] = tmpChar
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if trie.children[board[i][j]-'a'] != nil {
				dfs(trie, i, j, "")
			}
		}
	}
	return res
}
```

```go
func findWords(board [][]byte, words []string) []string {
	var res []string
	var tmpStr bytes.Buffer
	m, n := len(board), len(board[0])

	// 插入所有的word
	trie := &Trie{}
	for _, word := range words {
		trie.Insert(word)
	}

	var dfs func(trie *Trie, i int, j int)
	dfs = func(trie *Trie, i int, j int) {
		if i < 0 || j < 0 || i >= m || j >= n || board[i][j] == '#' || trie == nil {
			return
		}

		if trie.children[board[i][j]-'a'] != nil {
			if trie.children[board[i][j]-'a'].isEnd {
				res = append(res, tmpStr.String()+string(board[i][j]))
				// 删除这个前缀树的单词
				trie.children[board[i][j]-'a'].isEnd = false
			}
			tmpChar := board[i][j]
			board[i][j] = '#'
			tmpStr.WriteByte(tmpChar)
			dfs(trie.children[tmpChar-'a'], i+1, j)
			dfs(trie.children[tmpChar-'a'], i-1, j)
			dfs(trie.children[tmpChar-'a'], i, j+1)
			dfs(trie.children[tmpChar-'a'], i, j-1)
			tmpStr.Truncate(tmpStr.Len() - 1)
			board[i][j] = tmpChar
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if trie.children[board[i][j]-'a'] != nil {
				dfs(trie, i, j)
			}
		}
	}
	return res
}
```

> 起始先将所有 words 出现的单词放到 Set 结构中，然后以 board 中的每个点作为起点进行爆搜（由于题目规定在一个单词中每个格子只能被使用一次，因此还需要一个 vis 数组来记录访问过的位置）：
>
> 如果当前爆搜到的字符串长度超过 101010，直接剪枝；
> 如果当前搜索到的字符串在 Set 中，则添加到答案（同时了防止下一次再搜索到该字符串，需要将该字符串从 Set 中移除）。
>
> 
>
> ....................., 这个短一点还是有好处啊

```go
func findWords(board [][]byte, words []string) []string {
	var res []string
	var tmpRes bytes.Buffer
	dirs := []struct{ x, y int }{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}
	m, n := len(board), len(board[0])
	// 存入所有的字符
	wordMap := map[string]bool{}
	for _, word := range words {
		wordMap[word] = true
	}

	var dfs func(i, j int)
	dfs = func(i, j int) {
		if tmpRes.Len() > 10 || i < 0 || j < 0 || i >= m || j >= n || board[i][j] == '#' {
			return
		}

		tmpRes.WriteByte(board[i][j])
		tmpChar := board[i][j]
		board[i][j] = '#'
		if wordMap[tmpRes.String()] {
			res = append(res, tmpRes.String())
			wordMap[tmpRes.String()] = false
		}

		for _, pair := range dirs {
			dfs(i+pair.x, j+pair.y)
		}
		board[i][j] = tmpChar
		tmpRes.Truncate(tmpRes.Len() - 1)

	}
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			dfs(i, j)
		}
	}
	return res
}
```

# 树上算法

## LCA [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

> 我们从根节点开始遍历； 不使用LCA => 利用BST的特点
>
> 如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；
>
> 如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此将当前节点移动到它的右子节点；
>
> 如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，p 和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。
>

```go
func lowestCommonAncestor(root, p, q *TreeNode) (ancestor *TreeNode) {
    ancestor = root
    for {
        if p.Val < ancestor.Val && q.Val < ancestor.Val {
            ancestor = ancestor.Left
        } else if p.Val > ancestor.Val && q.Val > ancestor.Val {
            ancestor = ancestor.Right
        } else {
            return
        }
    }
}
```

## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230806120214263.png" alt="image-20230806120214263" style="zoom:67%;" />

> 直接DFS
>
> <img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230806121026272.png" alt="image-20230806121026272" style="zoom:67%;" />

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if root == nil || root == p || root == q {
		// 1 叶子节点, 直接返回
		// 当前位置是一个目标
		return root
	}

	// 找到左右儿子的搜索结果
	left := lowestCommonAncestor(root.Left, p, q)
	right := lowestCommonAncestor(root.Right, p, q)

	// 左右都找到了目标值
	// 这样的节点只会有一个
	if left != nil && right != nil {
		return root
	}

	// 只有一边有结果
	// 1 只找到了一个目标, 向上
	// 2 下层两个都找到了
	if left != nil {
		return left
	}
	return right
}
```









# 图

## [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230725234035358.png" alt="image-20230725234035358" style="zoom:67%;" />

> 跟链表一样, 哈希来进行

```go
func cloneGraph(node *Node) *Node {
	m := make(map[*Node]*Node)

	var deepCopy func(node *Node) *Node
	deepCopy = func(node *Node) *Node {
		if node == nil {
			return nil
		}

		if n, has := m[node]; has {
			return n
		}

		newNode := &Node{Val: node.Val}
		m[node] = newNode
		newNode.Neighbors = make([]*Node, 0)
		for _, neibor := range node.Neighbors {
			newNode.Neighbors = append(newNode.Neighbors, deepCopy(neibor))
		}
		return newNode
	}
	return deepCopy(node)
}
```







## [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230727112213952.png" alt="image-20230727112213952" style="zoom:67%;" />

> 肯定是遍历, 这种题目bfs肯定比dfs要好
>
> 写一个bfs很简单

```go
func ladderLength(beginWord string, endWord string, wordList []string) int {
	n := len(wordList)
	res := 0
	graph := make(map[string][]string)

	// 建图
	convertAble := func(s, t string) bool {
		cnt := 0
		for i := 0; i < len(s); i++ {
			if s[i] != t[i] {
				cnt++
			}
		}
		return cnt == 1
	}
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if convertAble(wordList[i], wordList[j]) {
				graph[wordList[i]] = append(graph[wordList[i]], wordList[j])
				graph[wordList[j]] = append(graph[wordList[j]], wordList[i])
			}
		}
	}
	// beginWord不在字典里面呀fk
	for i := 0; i < n; i++ {
		if convertAble(beginWord, wordList[i]) {
			graph[beginWord] = append(graph[beginWord], wordList[i])
		}
	}

	// 遍历
	queue := make([]string, 0)
	visited := make(map[string]bool)
	queue = append(queue, beginWord)
	for len(queue) != 0 {
		res += 1
		l := len(queue)
		for i := 0; i < l; i++ {
			visited[queue[i]] = true
			// 直接判断
			if queue[i] == endWord {
				return res
			}
		}
		// 出队入队新的
		for i := 0; i < l; i++ {
			pop := queue[0]
			queue = queue[1:]
			for _, word := range graph[pop] {
				if !visited[word] {
					queue = append(queue, word)
				}
			}
		}
	}
	// 到这步就代表无法转化
	return 0
}
```

> 优化建图
>
> - 每两个比较一次是否可转换太麻烦了
> - 所以直接创建虚拟节点
> - 使用哈希表建图, 要比使用二维数组建图简单太多了
> - 时间确实少了一些

```go
func ladderLength(beginWord string, endWord string, wordList []string) int {
	res := 0
	graph := make(map[string][]string)

	// 建图
	addEdge := func(word string) {
		s := []byte(word)
		for i, b := range s {
			s[i] = '*'
			graph[word] = append(graph[word], string(s))
			graph[string(s)] = append(graph[string(s)], word)
			s[i] = b
		}
	}
	for _, word := range wordList {
		addEdge(word)
	}
	addEdge(beginWord)

	// 遍历
	queue := make([]string, 0)
	visited := make(map[string]bool)
	queue = append(queue, beginWord)
	for len(queue) != 0 {
		l := len(queue)
		for i := 0; i < l; i++ {
			visited[queue[i]] = true
			// 直接判断
			if queue[i] == endWord {
				return res/2 + 1
			}
		}
		// 出队入队新的
		for i := 0; i < l; i++ {
			pop := queue[0]
			queue = queue[1:]
			for _, word := range graph[pop] {
				if !visited[word] {
					queue = append(queue, word)
				}
			}
		}
		res += 1
		fmt.Println(res, queue)
	}
	// 到这步就代表无法转化
	return 0
}
```

> 双向BFS
>
> <img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230727115640491.png" alt="image-20230727115640491" style="zoom:67%;" />

```go
func ladderLength(beginWord string, endWord string, wordList []string) int {
	resBegin, resEnd := 0, 0
	graph := make(map[string][]string)

	// 建图
	addEdge := func(word string) {
		s := []byte(word)
		for i, b := range s {
			s[i] = '*'
			graph[word] = append(graph[word], string(s))
			graph[string(s)] = append(graph[string(s)], word)
			s[i] = b
		}
	}
	for _, word := range wordList {
		addEdge(word)
	}
	addEdge(beginWord)

	// 遍历
	queueStart := make([]string, 0)
	visitedStart := make(map[string]bool)
	queueStart = append(queueStart, beginWord)
	queueEnd := make([]string, 0)
	visitedEnd := make(map[string]bool)
	queueEnd = append(queueEnd, endWord)

	for len(queueStart) != 0 && len(queueEnd) > 0 {
		// 前向遍历
		l := len(queueStart)
		for i := 0; i < l; i++ {
			visitedStart[queueStart[i]] = true
			// 如果在后向
			// 其实这一步可以省略
			//if visitedEnd[queueStart[i]] {
			//	return (resBegin+resEnd)/2 + 1
			//}
		}
		// 出队入队新的
		for i := 0; i < l; i++ {
			pop := queueStart[0]
			queueStart = queueStart[1:]
			for _, word := range graph[pop] {
				if !visitedStart[word] {
					queueStart = append(queueStart, word)
				}
			}
		}
		resBegin += 1

		l = len(queueEnd)
		for i := 0; i < l; i++ {
			visitedEnd[queueEnd[i]] = true
			if visitedStart[queueEnd[i]] {
				return (resBegin+resEnd)/2 + 1
			}
		}
		// 出队入队新的
		for i := 0; i < l; i++ {
			pop := queueEnd[0]
			queueEnd = queueEnd[1:]
			for _, word := range graph[pop] {
				if !visitedEnd[word] {
					queueEnd = append(queueEnd, word)
				}
			}
		}
		resEnd += 1
	}
	// 到这步就代表无法转化
	return 0
}
```

## [126. 单词接龙 II](https://leetcode.cn/problems/word-ladder-ii/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230727121007978.png" alt="image-20230727121007978" style="zoom:67%;" />

> 不同的是, 这个要求记录转换序列
>
> 明显看数据条件应该是不支持dfs的, 所以好药bfs
>
> 如何写带状态记录的bfs???

> 本题所求为从beginWord到endWord的最短路径问题，单词接龙1只需要求出一组就行，单词接龙二需要求出所有的最短路径，那么求所有的路径，必然用到dfs。求最短路径必然用到bfs。所以本题是bfs和dfs的混合题目。
>
> 本题对于时间的要求十分严格, 我必须要进入20ms

> 本题完全可以构建有向图
>
> - 而且是在bfs的过程中构建的有向图
> - 使用cnt计数和任意字符替换, 好像都是一样的
> - 双向bfs优化就先不写了

```go
func findLadders(beginWord string, endWord string, wordList []string) [][]string {
	//字典表（将wordList中的单词放入hash表中，方便查找）
	dict := make(map[string]bool, 0)
	res := make([][]string, 0) //保存结果
	for _, v := range wordList {
		dict[v] = true
	}
	dict[beginWord] = true

	//如果endWord不在hash表中，表示不存在转换列表，返回空集合
	if !dict[endWord] {
		return [][]string{}
	}

	// 获得当前节点的所有邻接点
	// 通过交换每一位的所有字母来实现的
	//expand := func(word string) []string {
	//	expansion := make([]string, 0) //保存word的邻接点
	//	//从word的每一位开始
	//	chs := []rune(word)
	//	for i := 0; i < len(word); i++ {
	//		tmp := chs[i] //保存当前位，方便后序进行复位
	//		for c := 'a'; c <= 'z'; c++ {
	//			//如果一样则直接跳过，之所以用tmp，是因为chs[i]在变
	//			if tmp == c {
	//				continue
	//			}
	//			chs[i] = c
	//			newstr := string(chs)
	//			//新单词在dict中不存在，则跳过
	//			if dict[newstr] {
	//				expansion = append(expansion, newstr)
	//			}
	//		}
	//		chs[i] = tmp //单词位复位
	//	}
	//	return expansion
	//}
	expand := func(word string) []string {
		expansion := make([]string, 0) //保存word的邻接点
		for w, _ := range dict {
			cnt := 0
			for i := 0; i < len(word); i++ {
				if word[i] != w[i] {
					cnt++
				}
			}
			if cnt == 1 {
				expansion = append(expansion, w)
			}
		}
		return expansion
	}

	//构建邻接表
	graph := make(map[string][]string, 0)

	//执行bfs搜索，找到每个点到endWord的距离
	// 从终点出发，进行bfs，计算每一个点到达终点的距离
	distance := make(map[string]int, 0) //每个点到终点的距离
	queue := []string{endWord}
	distance[endWord] = 0 //初始值
	for len(queue) != 0 {
		cursize := len(queue)
		for i := 0; i < cursize; i++ {
			word := queue[0]
			queue = queue[1:]
			//找到和word有一位不同的单词列表
			expansion := expand(word)
			for _, v := range expansion {
				//构造邻接表, 只构建单向的图
				//我们是从beginWord到endWord构造邻接表，而bfs是从endWord开始，所以构造时，反过来构造
				//即graph[v]=append(graph[v],word)而不是graph[word]=append(graph[word],v)
				graph[v] = append(graph[v], word)
				//表示没访问过
				if _, ok := distance[v]; !ok {
					distance[v] = distance[word] + 1 //距离加一
					queue = append(queue, v)         //入队列
				}
			}
		}
	}

	var dfs func(beginWord string, endWord string, path []string)
	dfs = func(beginWord string, endWord string, path []string) {
		//出递归条件
		if beginWord == endWord {
			res = append(res, append([]string(nil), append(path, beginWord)...))
			return
		}
		//否则遍历图
		for _, v := range graph[beginWord] {
			//遍历图时，朝着距离与终点越来越近的方向进行（当前节点的距离肯定要比下一个距离大1）
			if distance[beginWord] == distance[v]+1 {
				path = append(path, beginWord)
				dfs(v, endWord, path)
				//回溯（执行完上述的所有时，将其回溯回去）
				path = path[:len(path)-1]
			}
		}
	}

	//执行dfs操作
	dfs(beginWord, endWord, []string{})
	return res
}
```



## P3916 图的遍历

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230830101802484.png" alt="image-20230830101802484" style="zoom:67%;" />

> - 反向建边
> - //只会dfs
>   //有多个点到一个点可以转成一个点到多个点
>   //所以可以反向建边，然后编号从大到小dfs。
>   //复杂度O（n），每个点只遍历一次
> - 对于一个叶子结点, dfs就是自己,不用改变
> - 节点序号的大小比较也进行了限制
> - res的初始值都是i

```go
func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var n, m int
	fmt.Fscan(in, &n, &m)
	graph := make(map[int][]int)
	for i := 0; i < m; i++ {
		var u, v int
		fmt.Fscan(in, &u, &v)
		graph[v] = append(graph[v], u)
	}

	visit := make([]bool, n+1, n+1)
	res := make([]int, n+1, n+1)
	for i := 1; i <= n; i++ {
		res[i] = i
	}

	var dfs func(node int)
	dfs = func(node int) {
		for _, ancestor := range graph[node] {
			if !(visit)[ancestor] {
				visit[ancestor] = true
				res[ancestor] = max(res[node], res[ancestor])
				dfs(ancestor)
			}
		}
	}
	
    // 每一个点都来一次
	for i := n; i >= 1; i-- {
		dfs(i)
	}

	for i := 1; i <= n; i++ {
		fmt.Printf("%d ", res[i])
	}
}
```



## P3366 【模板】最小生成树

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230830103920412.png" alt="image-20230830103920412" style="zoom:67%;" />

> - 有向图使用哈希表
> - 有权值图使用 自定义结构体

```go
// 并查集最大de
const N = 2*10e5 + 1

// 先写一个边结构
type edge struct {
	start, end, dist int
}

// 再写一个并查集
type union struct {
	root [N]int
}

// 初始化
func initUnion(u *union, n int) {
	for i := 1; i <= n; i++ {
		u.root[i] = i
	}
}

func find(x int, u *union) int {
	if x != u.root[x] {
		u.root[x] = find(u.root[x], u)
	}
	return u.root[x]
}

func union2(x, y int, u *union) {
	xr := find(x, u)
	yr := find(y, u)
	if xr != yr {
		u.root[xr] = yr
	}
}

func connected(x, y int, u *union) bool {
	return find(x, u) == find(y, u)
}

type edgeset []edge

var edges = make(edgeset, 0, N)

func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var n, m int
	fmt.Fscan(in, &n, &m)

	// 读取边
	for i := 0; i < m; i++ {
		var x, y, z int
		fmt.Fscan(in, &x, &y, &z)
		edges = append(edges, edge{x, y, z})
	}

	// 对于边集进行排序
	sort.Slice(edges, func(i, j int) bool {
		return edges[i].dist < edges[j].dist
	})

	// 合并
	var res, cnt int
	u := union{}
	initUnion(&u, n+1)

	for i := 0; i < m; i++ {
		tmpEdge := edges[i]
		if !connected(tmpEdge.start, tmpEdge.end, &u) {
			res += tmpEdge.dist
			cnt += 1
			union2(tmpEdge.start, tmpEdge.end, &u)
			if cnt == n-1 {
				fmt.Println(res)
				return
			}
		}
	}
	fmt.Println("orz")
}
```



## P4779 【模板】单源最短路径（标准版）

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20230830104536110.png" alt="image-20230830104536110" style="zoom:67%;" />

> - 学习一下链式前向星

```go
type e struct{ next, to, w int }

var es = make([]e, 2*10e5+1, 2*10e5+1)
var head = make([]int, 2*10e5+1, 2*10e5+1)
var cnt int = 0

func addEdge(u, v, w int) {
	cnt++
	es[cnt].next = head[u]
	es[cnt].to = v
	es[cnt].w = w
	head[u] = cnt
}

func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var n, m, s, u, v, w int
	fmt.Fscan(in, &n, &m, &s)
	for i := 0; i < m; i++ {
		fmt.Fscan(in, &u, &v, &w)
		addEdge(u, v, w)
	}

	dist := make([]int, n+1, n+1)
	visit := make([]bool, n+1, n+1)
	for i := 1; i <= n; i++ {
		dist[i] = 2147483647
	}

	dist[s] = 0
	pos := s
	for visit[pos] == false {
        // 更新所有连接点
		visit[pos] = true
		for i := head[pos]; i != 0; i = es[i].next {
			if !visit[es[i].to] && dist[es[i].to] > dist[pos]+es[i].w {
				dist[es[i].to] = dist[pos] + es[i].w
			}
		}
        
        // 下一个起点
		minVal := int(2e9 + 2)
		for i := 1; i <= n; i++ {
			if dist[i] < minVal && visit[i] == false {
				minVal = dist[i]
				pos = i
			}
		}
	}

	for i := 1; i <= n; i++ {
		fmt.Fprintf(out, "%d ", dist[i])
	}
}
```





# 拓扑排序



## [841/86. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

<img src="./%E6%A0%91-%E5%9B%BE.assets/image-20231204235835113.png" alt="image-20231204235835113" style="zoom:80%;" />



> 这个拓扑排序是直接从0开始的
>
> - 比普通的更easy, 不用计算inDegree

```go
func canVisitAllRooms(rooms [][]int) bool {
	n, cnt := len(rooms), 1
	visit := make(map[int]bool, 0)
	visit[0] = true
	queue := []int{0}

	for len(queue) != 0 {
		t := queue[0]
		queue = queue[1:]
		for _, next := range rooms[t] {
			if _, has := visit[next]; !has {
				cnt++
				visit[next] = true
				queue = append(queue, next)
			}
		}
	}

	return cnt == n // 所有屋子都进去过了
}
```









































































