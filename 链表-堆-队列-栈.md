# 链表

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230714163250613.png" alt="image-20230714163250613" style="zoom:67%;" />

> 几个条件在for循环一起判断, 使用or
>
> 在里面再单独的进行每个条件的判断

```go
type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	sum := 0
	ret := &ListNode{Val: 0, Next: nil}
	ptr := ret
    // 这三个一起判断, 免去了之后的一些边界条件
	for l1 != nil || l2 != nil || sum != 0 {
		if l1 != nil {
			sum += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			sum += l2.Val
			l2 = l2.Next
		}
        // 这样写的话, 不需要一个进位变量了
		ptr.Next = &ListNode{Val: sum % 10, Next: nil}
		ptr = ptr.Next
		sum /= 10
	}
	return ret.Next
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230716160942980.png" alt="image-20230716160942980" style="zoom:67%;" />

> 先走n-1步, 此时head就是倒数第N个, 下一个是nil, 去掉head
>
> 在向后走一步, 双指针一直延续

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	if head == nil {
		return nil
	}
	var tailN, tmp *ListNode = head, head
    
    // 先走到head是倒数第N
	for i := 0; i < n-1; i++ {
		if tailN.Next == nil {
			return head
		}
		tailN = tailN.Next
	}
	if tailN.Next == nil {
        // head是倒数第N
		return head.Next
	} else {
        // 不是的话, 让head.Next是倒数第N
		tailN = tailN.Next
		for tailN.Next != nil {
			tmp, tailN = tmp.Next, tailN.Next
		}
		tmp.Next = tmp.Next.Next
		return head
	}
}
```



## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230717092838508.png" alt="image-20230717092838508" style="zoom:67%;" />

> 当只有一个链表的时候, 直接连接就行了,不用一个个拆
>
> 递归形式的更简单

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	head := &ListNode{Next: nil}
	tmp := head

	for list1 != nil && list2 != nil {
		if list1.Val < list2.Val {
			tmp.Next = list1
			list1 = list1.Next
		} else {
			tmp.Next = list2
			list2 = list2.Next
		}
		tmp = tmp.Next
		tmp.Next = nil
	}
	if list1 != nil {
		tmp.Next = list1
	}

	if list2 != nil {
		tmp.Next = list2
	}
	return head.Next
}
```

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}
```



## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230717143834534.png" alt="image-20230717143834534" style="zoom:67%;" />

> 递归写法 good
>
> 在每一轮的递归中变换一轮
>
> 
>
> 常规的循环写法就是要细心一点

```go
func swapPairs(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	tmpHead := head.Next
	head.Next = swapPairs(tmpHead.Next)
	tmpHead.Next = head
	return tmpHead
}


func swapPairs(head *ListNode) *ListNode {
	dummy := &ListNode{Next: head}
	if dummy.Next == nil || dummy.Next.Next == nil {
		return dummy.Next
	}

	t1, t2 := dummy.Next, dummy.Next.Next
	t3 := dummy
	for {
		t1.Next, t2.Next, t3.Next = t2.Next, t1, t2
		t3 = t1
		if t3.Next == nil || t3.Next.Next == nil {
			break
		} else {
			t1, t2 = t3.Next, t3.Next.Next
		}
	}
	return dummy.Next
}
```

## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230717145325712.png" alt="image-20230717145325712" style="zoom:67%;" />

> 与24一致的, 递归+常规
>
> 可以直接获取最大长度来获得次数

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
	if head == nil || k == 1 {
		return head
	}
	// 长度
	var length int = 0
	tmp := head
	for tmp != nil {
		length += 1
		tmp = tmp.Next
	}
    // 翻转次数
	var times int = length / k
	ret := &ListNode{Val: 0, Next: nil}
	ret_tmp := ret
	tmp1 := head
	tmp2 := head.Next
	for i := 0; i < times; i++ {
		tmp3 := tmp1
		for j := 0; j < k; j++ {
			tmp1.Next = ret_tmp.Next
			ret_tmp.Next = tmp1
			tmp1 = tmp2
            // 只在最后一轮的最后一处会发生
			if tmp2 != nil {
				tmp2 = tmp2.Next
			}
		}
		ret_tmp = tmp3
	}
	ret_tmp.Next = tmp1
	return ret.Next
}


func reverseKGroup(head *ListNode, k int) *ListNode {
	if k == 1 {
		return head
	}
	tmp := head
	for i := 0; i < k; i++ {
		if tmp == nil {
			return head
		}
		tmp = tmp.Next
	}

	dummy := &ListNode{Next: nil}
	t1, t2 := head, head.Next
	for i := 0; i < k; i++ {
		t1.Next = dummy.Next
		dummy.Next = t1
		t1 = t2
		if t2 != nil {
			// 长度整除k, 后面不能再向后
			t2 = t2.Next
		}
	}
	head.Next = reverseKGroup(t1, k)
	return dummy.Next
}
```

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230717152614608.png" alt="image-20230717152614608" style="zoom:50%;" />



## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230720144745379.png" alt="image-20230720144745379" style="zoom:67%;" />

> 尾结点, 长度, 断开处
>
> 有可能k很大, 导致循环的!!!

```go
func rotateRight(head *ListNode, k int) *ListNode {
	if head == nil {
		return nil
	}
	tail := head
	length := 1
	for tail.Next != nil {
		length += 1
		tail = tail.Next
	}

    // 防止k太大导致循环  
	k = k % length
	if k == 0 {
		return head
	}
	tmp := head
	for i := 0; i < length-k-1; i++ {
		tmp = tmp.Next
	}
	ret := tmp.Next
	tmp.Next = nil
	tail.Next = head
	return ret
}
```

## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230722151054042.png" alt="image-20230722151054042" style="zoom:67%;" />

> emmmmmm easy
>
> dummy节点还是ok的, 链表题目基本都得加上
>
> - nil == nil ? 是的哦, 这是一个预定义的标识符
> - right从dummy右移r+1
> - left 从 dummy右移 l-1

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	dummy := &ListNode{Next: head}
	l, r := dummy, dummy
	// 右移
	for i := 0; i < left-1; i++ {
		l = l.Next
	}
	for i := 0; i < right+1; i++ {
		r = r.Next
	}

	// 头插法, 在头部后面先设置nil
	t, t1 := l, l.Next
	// 保留头插法最后的尾部信息, 直接连上right
	tail := t1
	for t1 != r {
		// 这种变量交换很方便
		t.Next, t1.Next, t1 = t1, t.Next, t1.Next
	}
	tail.Next = r
	return dummy.Next
}
```



## [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230722152252422.png" alt="image-20230722152252422" style="zoom:67%;" />

> 链表的双指针呗
>
> 可以递归写的吧, 题解里面必定有
>
> - 找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return
> - 想想应该返回什么值：应该返回的自然是已经去重的链表的头节点
> - 每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head

```go
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil {
		return nil
	}
	l, r := head, head.Next
	for r != nil {
		if r.Val == l.Val {
            // 往下连接节点
			l.Next, r = r.Next, r.Next
		} else {
			l, r = r, r.Next
		}
	}
	return head
}
```

```go
// 这个相当于从后向前剔除
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	head.Next = deleteDuplicates(head.Next)
	if head.Val == head.Next.Val {
		head = head.Next
	}
	return head
}
```



## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230722153325230.png" alt="image-20230722153325230" style="zoom:67%;" />

> 加一个dummy节点就行啦啦啦啦
>
> - 边界条件有点多
> - 一定得自己好好模拟一下哈, 模拟明白边界条件就ok
> - 往后遍历, 判断后一个不为空,且与自己这个比较, 要比我自己写的这个b玩意清楚多了
> - 但是我的双指针法也没啥问题啊
>
> 更简单的方法:
>
> - 重新创建一个头结点, 遍历这个链表, 往里面插入, 逻辑更好些一点
> - 也可以哈希表两次遍历＋计数, 也是相当ok的
>
> 怎么递归还得想一想哈
>
> - 即便是递归, 也要在里面写一点逻辑啊, 哪有爬楼梯那么纯粹的递归啊
> - 如果 `head` 为空，那么肯定没有值出现重复的节点，直接返回 head；
> - 如果 `head.next` 为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回 head。
> - 如果 head.val != head.next.val ，说明头节点的值不等于下一个节点的值，所以当前的 head 节点必须保留；但是 head.next 节点要不要保留呢？我们还不知道，需要对 head.next 进行递归，即对 head.next 作为头节点的链表，去除值重复的节点。所以 head.next = self.deleteDuplicates(head.next).
>
> - 如果 head.val == head.next.val ，说明头节点的值等于下一个节点的值，所以当前的 head 节点必须删除，并且 head 之后所有与 head.val 相等的节点也都需要删除；删除到哪个节点为止呢？需要用 move 指针一直向后遍历寻找到与 head.val 不等的节点。此时 move 之前的节点都不保留了，因此返回 deleteDuplicates(move);
> - 如果 `head.val != head.next.val` ，头结点需要保留，因此返回的是 `head`；
> - 如果 `head.val == head.next.val` ，头结点需要删除，需要返回的是`deleteDuplicates(move);`。

```go

func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil {
		return nil
	}
	dummy := &ListNode{Next: head}
	t, l, r := dummy, head, head.Next
	for r != nil {
		for r != nil && r.Val == l.Val {
			r = r.Next
		}
		// 终止了
		if r == nil {
			break
		}
		// l这个是独一无二的
		if r == l.Next {
			// 连接上, 指针移动
			t.Next, t, l, r = l, l, l.Next, r.Next
			t.Next = nil
		} else {
			// l是重复的, 跳过
			l, r = r, r.Next
		}
	}

	// 最后一个数是独一无二的
	if l.Next == r {
		t.Next = l
	} else {
		t.Next = nil
	}

	return dummy.Next
}
```

```go
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	if head.Val != head.Next.Val {
		head.Next = deleteDuplicates(head.Next)
	} else {
		for head.Next != nil && head.Val == head.Next.Val {
			head = head.Next
		}
		return deleteDuplicates(head.Next)
	}
	return head
}
```

## [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230722221425402.png" alt="image-20230722221425402" style="zoom:67%;" />

> dummy1 dummy2 不就ok了吗???????????????

```go
func partition(head *ListNode, x int) *ListNode {
	// 边缘条件
	if head == nil || head.Next == nil {
		return head
	}

	// 两个虚拟节点
	dummy1, dummy2 := &ListNode{}, &ListNode{}
	t1, t2 := dummy1, dummy2

	for head != nil {
		if head.Val < x {
			t1.Next = head
			head = head.Next
			t1 = t1.Next
		} else {
			t2.Next = head
			head = head.Next
			t2 = t2.Next
		}
	}
	// 断掉
	t2.Next = nil
	t1.Next = dummy2.Next
	return dummy1.Next
}
```

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725001852748.png" alt="image-20230725001852748" style="zoom:67%;" />

> 哈希表存放节点, 这个肯定是easy的, 都是on
>
> 快慢指针
>
> - 们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。
> - 为什么我们要规定初始时慢指针在位置 `head`，快指针在位置 `head.next`，而不是两个指针都在位置 `head`（即与「乌龟」和「兔子」中的叙述相同）？
>   - 我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。
>

```go
func hasCycle(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return false
	}
	slow, fast := head, head.Next
	for fast != slow {
		if fast == nil || fast.Next == nil {
			return false
		}
		slow = slow.Next
		fast = fast.Next.Next
	}
	return true
}
```

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725154125535.png" alt="image-20230725154125535" style="zoom:67%;" />

> 找到入环的第一个节点
>
> - 哈希表, 最简单的方法了
>
> 快慢指针
>
> - **双指针第一次相遇：** 设两指针 `fast`，`slow` 指向链表头部 `head`，`fast` 每轮走 222 步，`slow` 每轮走 111 步；
>   - **第一种结果：** `fast` 指针走过链表末端，说明链表无环，直接返回 `null`；
> - **第二种结果：** 当`fast == slow`时， 两指针在环中 **第一次相遇** 。下面分析此时`fast` 与 `slow`走过的 **步数关系** ：
> - <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725161050201.png" alt="image-20230725161050201" style="zoom:50%;" />
> - <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725161202085.png" alt="image-20230725161202085" style="zoom:50%;" />

```go
func detectCycle(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast != nil {
		slow = slow.Next
		if fast.Next == nil {
			return nil
		}
		fast = fast.Next.Next
		if fast == slow {
			p := head
			for p != slow {
				p = p.Next
				slow = slow.Next
			}
			return p
		}
	}
	return nil
}
```









## [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725102221539.png" alt="image-20230725102221539" style="zoom:67%;" />

> 我还以为有什么大方法呢
>
> - dummy头结点
> - lsatSort维护最后一个已排序
> - $O(N^2)$

```go
func insertionSortList(head *ListNode) *ListNode {
	dummyHead := &ListNode{Next: head, Val: math.MinInt}
	lastSorted := dummyHead

	for lastSorted.Next != nil {
		// 排在最后
		if lastSorted.Next.Val >= lastSorted.Val {
			lastSorted = lastSorted.Next
		} else if dummyHead.Next.Val >= lastSorted.Next.Val {
			// 排在头
			t := lastSorted.Next
			lastSorted.Next = t.Next
			t.Next = dummyHead.Next
			dummyHead.Next = t
		} else {
			// 排在中间
			t1 := dummyHead.Next
			t2 := lastSorted.Next
			for t1.Next.Val < lastSorted.Next.Val {
				t1 = t1.Next
			}
			lastSorted.Next = lastSorted.Next.Next
			t2.Next = t1.Next
			t1.Next = t2
		}
	}
	return dummyHead.Next
}
```

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725103803534.png" alt="image-20230725103803534" style="zoom:67%;" />

> <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725103904517.png" alt="image-20230725103904517" style="zoom: 67%;" />

> 自顶向下的归并排序
>
> 就是普通的归并排序啦
>
> 空间复杂度是递归调用的栈深度

```go
func sortList(head *ListNode) *ListNode {
	merge := func(head1, head2 *ListNode) *ListNode {
		dummy := &ListNode{Next: nil}
		t, h1, h2 := dummy, head1, head2
		for h1 != nil && h2 != nil {
			if h1.Val < h2.Val {
				t.Next = h1
				h1 = h1.Next
			} else {
				t.Next = h2
				h2 = h2.Next
			}
			// 这句话怎么能忘写呢? sb
			t = t.Next
		}
		// 直接相连, 不要for啦
		if h1 != nil {
			t.Next = h1
		} else if h2 != nil {
			t.Next = h2
		}
		return dummy.Next
	}

	var sort func(head, tail *ListNode) *ListNode
	sort = func(head, tail *ListNode) *ListNode {
		// 终止条件
		if head == nil {
			return head
		}
		// 左闭右开, 记得得断开链子
		if head.Next == tail {
			head.Next = nil
			return head
		}
		low, fast := head, head
		for fast != tail {
			low = low.Next
			fast = fast.Next
			if fast != tail {
				fast = fast.Next
			}
		}
		mid := low
		// 两端继续进行
		return merge(sort(head, mid), sort(mid, tail))
	}
	return sort(head, nil)
}
```

> 自底向上归并排序
>
> 使用自底向上的方法实现归并排序，则可以达到O*(1) 的空间复杂度。
>
> 首先求得链表的长度 length，然后将链表拆分成子链表进行合并。

```go
func sortList(head *ListNode) *ListNode {
	if head == nil {
		return head
	}

	// 合并的方法, 这个是都不变的, 很easy
	merge := func(head1, head2 *ListNode) *ListNode {
		dummy := &ListNode{Next: nil}
		t, h1, h2 := dummy, head1, head2
		for h1 != nil && h2 != nil {
			if h1.Val < h2.Val {
				t.Next = h1
				h1 = h1.Next
			} else {
				t.Next = h2
				h2 = h2.Next
			}
			// 这句话怎么能忘写呢? sb
			t = t.Next
		}
		// 直接相连, 不要for啦
		if h1 != nil {
			t.Next = h1
		} else if h2 != nil {
			t.Next = h2
		}
		return dummy.Next
	}

	length := 0 // 获取长度
	for node := head; node != nil; node = node.Next {
		length++
	}

	dummyHead := &ListNode{Next: head}

	// 长度从1开始的哈哈, 长度翻倍
    // 先由cur切出两块, 再交给prev连上
	for subLength := 1; subLength < length; subLength <<= 1 {
		prev, cur := dummyHead, dummyHead.Next
		for cur != nil {
			head1 := cur
			for i := 1; i < subLength && cur.Next != nil; i++ {
				cur = cur.Next
			}

			head2 := cur.Next
			cur.Next = nil
			cur = head2
			for i := 1; i < subLength && cur != nil && cur.Next != nil; i++ {
				cur = cur.Next
			}

			var next *ListNode
			if cur != nil {
				next = cur.Next
				cur.Next = nil
			}

			prev.Next = merge(head1, head2)
			for prev.Next != nil {
				prev = prev.Next
			}
			cur = next
		}
	}
	return dummyHead.Next
}
```



## [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725165814182.png" alt="image-20230725165814182" style="zoom:67%;" />



> 遍历找到长度
>
> 从中间断开
>
> 后半部分倒序
>
> 之后连接, tnnd, 原来题解也是这么写的

```go
func reorderList(head *ListNode) {
	length := 0 // 记录长度
	for t := head; t != nil; t = t.Next {
		length++
	}

	// 分成两部分
	dummy1, dummy2 := &ListNode{}, &ListNode{}
	t := head
	for i := 0; i < length/2-1; i++ {
		t = t.Next
	}
	dummy2.Next = t.Next
	t.Next = nil

	// 第二部分倒序
	t = dummy2.Next
	dummy2.Next = nil
	for t != nil {
		tmp := t.Next
		t.Next = dummy2.Next
		dummy2.Next = t
		t = tmp
	}

	// 相连接
	t1 := dummy1
	t2 := dummy2.Next
	h := head
	for h != nil || t2 != nil {
		if h != nil {
			t1.Next = h
			h = h.Next
			t1 = t1.Next
		}
		if t2 != nil {
			t1.Next = t2
			t2 = t2.Next
			t1 = t1.Next
		}
	}
}
```



## [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725220739686.png" alt="image-20230725220739686" style="zoom:67%;" />

> 我能想到的就是哈希了
>
> 我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。
>
> 时空都是O(N)

```go
func copyRandomList(head *Node) *Node {
	var deepCopy func(node *Node) *Node
	m := make(map[*Node]*Node)
	deepCopy = func(node *Node) *Node {
		if node == nil {
			return nil
		}

		if n, has := m[node]; has {
			return n
		}
		// 肯定是先更新哈希表再递归啊
		newNode := &Node{Val: node.Val}
		m[node] = newNode

		newNode.Next = deepCopy(node.Next)
		newNode.Random = deepCopy(node.Random)
		return newNode
	}
	return deepCopy(head)
}
```



> <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725223659275.png" alt="image-20230725223659275" style="zoom:50%;" />
>
> 时间 N  空间 1

```go
func copyRandomList(head *Node) *Node {
	if head == nil {
		return nil
	}

	// 每个节点后面插入一个copy
	for node := head; node != nil; node = node.Next.Next {
		node.Next = &Node{Val: node.Val, Next: node.Next}
	}

	// 连接Random,
	for node := head; node != nil; node = node.Next.Next {
		if node.Random != nil {
			node.Next.Random = node.Random.Next
		}
	}
	headNew := head.Next
	for node := head; node != nil; node = node.Next {
		nodeNew := node.Next
		// 保证原来的不变
		node.Next = node.Next.Next
		if nodeNew.Next != nil {
			nodeNew.Next = nodeNew.Next.Next
		}
	}
	return headNew
}
```

## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230727104038402.png" alt="image-20230727104038402" style="zoom:67%;" />

> 直接一个哈希

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	m := make(map[*ListNode]int)
	for headA != nil{
		m[headA] = 1
		headA = headA.Next
	}
	for headB != nil{
		if m[headB]!= 0{
			return headB
		}
		headB = headB.Next
	}
	return nil
}
```

> 如何快慢指针呢?
>
> <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230727104427484.png" alt="image-20230727104427484" style="zoom:67%;" />
>
> 目的是为了消除长度差
>
> 长度a(单独的), b(单独的), c(共同的)
>
> 走两轮就是a+c+b, b+c+a, 正好都到交叉点了

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	pa, pb := headA, headB
	for pa != pb {
		if pa == nil {
			pa = headB
		} else {
			pa = pa.Next
		}

		if pb == nil {
			pb = headA
		} else {
			pb = pb.Next
		}
	}
	return pa
}
```



## [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230728111730075.png" alt="image-20230728111730075" style="zoom:67%;" />

```go
func removeElements(head *ListNode, val int) *ListNode {
	dummy := &ListNode{Next: head}
	t := dummy
	for t.Next != nil {
		for t.Next != nil && t.Next.Val == val {
			t.Next = t.Next.Next
		}
		if t.Next != nil {
			t = t.Next
		}
	}
	return dummy.Next
}
```

> 写个递归

```go
func removeElements(head *ListNode, val int) *ListNode {
	if head == nil {
		return nil
	}
	dummy := &ListNode{Next: head}
	if head.Val == val {
		dummy.Next = removeElements(head.Next, val)
	} else {
		head.Next = removeElements(head.Next, val)
	}
	return dummy.Next
}
```

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230802144311739.png" alt="image-20230802144311739" style="zoom:67%;" />

> 递归也得会呀

```go
func reverseList(head *ListNode) *ListNode {
	dummy := &ListNode{}
	for head != nil {
		t := head
		head = head.Next
		t.Next = dummy.Next
		dummy.Next = t
	}
	return dummy.Next
}


// head.Next.Next 已经是最后面得了啊
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	newHead := reverseList(head.Next)
	head.Next.Next = head
	head.Next = nil
	return newHead
}
```

## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230806110346921.png" alt="image-20230806110346921" style="zoom:67%;" />

> - 直接读取所有的节点 => ok啦
>
> - 递归 都是on
>
>   - 这个是要从头到位的遍历, 每个都是比较了两次
>   - 这个真的秒啊, 利用闭包, 将头结点一直向后
>   - 核心就是一个从前向后, 一个从后向前
>
> - 快慢指针
>
>   - 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。
>
>     该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。
>
>   - 都是slow, fast从head开始, 一个走一步, 一个走两步

```go
func isPalindrome(head *ListNode) bool {
    frontPointer := head
    var recursivelyCheck func(*ListNode) bool
    recursivelyCheck = func(curNode *ListNode) bool {
        if curNode != nil {
            if !recursivelyCheck(curNode.Next) {
                return false
            }
            if curNode.Val != frontPointer.Val {
                return false
            }
            frontPointer = frontPointer.Next
        }
        return true
    }
    return recursivelyCheck(head)
}
```



## [237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230806160932110.png" alt="image-20230806160932110" style="zoom:67%;" />

> 没有给到前面的节点
>
> 后面一定有节点
>
> 所以 => 李代桃僵

```go
func deleteNode(node *ListNode) {
	node.Val, node.Next.Val, node.Next = node.Next.Val, node.Val, node.Next.Next
}
```





# 栈

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230716161409647.png" alt="image-20230716161409647" style="zoom:67%;" />

> 简单的栈, 也可以使用字符串替换
>
> for range 遍历string 是rune, 可以与byte比较, 但是不能存入byte的slice

```go
func isValid(s string) bool {
	foo := func(i rune) int {
		if i == '(' || i == ')' {
			return 1
		} else if i == '[' || i == ']' {
			return 2
		}
		return 3
	}

	stack := make([]rune, 0)
	for _, c := range s {
		if c == '(' || c == '{' || c == '[' {
			stack = append(stack, c)
		} else {
			if len(stack) == 0 || foo(stack[len(stack)-1]) != foo(c) {
				return false
			} else {
				stack = stack[:len(stack)-1]
			}
		}
	}
	return len(stack) == 0
}
```



## [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230722172354354.png" alt="image-20230722172354354" style="zoom:67%;" />

> - 保存的是柱子的下表
>   - 当比栈顶高 入栈
>   - 弹出, 直至入栈
> - 以O(1)时间找到以栈顶柱子为高的矩形的左右边界

```go
func largestRectangleArea(heights []int) int {
	if len(heights) == 0 {
		return 0
	}

	// 单调栈
	stack := make([]int, 0)
	res := 0
	// 方便处理边界, 保证所有数字都可以弹出计算
	heights = append(heights, 0)

	for i := 0; i < len(heights); i++ {
		for len(stack) != 0 && heights[stack[len(stack)-1]] > heights[i] {
			// 栈顶元素
			curr_height := heights[stack[len(stack)-1]]

			// 右边界
			// curr_height在遍历到第i个的时候被弹出, 代表直到i-1都是比它大的
			right_border := i - 1

			stack = stack[:len(stack)-1]

			//左边界, 如果stack没有元素, 代表一直向左都比这个大, 左边界可延伸
			left_border := 0
			if len(stack) != 0 {
				left_border = stack[len(stack)-1] + 1
			}

			if t := curr_height * (right_border - left_border + 1); t > res {
				res = t
			}
		}
		stack = append(stack, i)
	}
	return res
}
```

## [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230723001923570.png" alt="image-20230723001923570" style="zoom:67%;" />

> 每一层看作是柱状图，可以套用84题柱状图的最大面积。
>
> 第一层柱状图的高度["1","0","1","0","0"]，最大面积为1；
>
> 第二层柱状图的高度["2","0","2","1","1"]，最大面积为3；
>
> 第三层柱状图的高度["3","1","3","2","2"]，最大面积为6；
>
> 第四层柱状图的高度["4","0","0","3","0"]，最大面积为4；
>
> - 全部转化为单调栈问题了

```go
func maximalRectangle(matrix [][]byte) int {
	res := 0
	// 方便处理边界, 保证所有数字都可以弹出计算 多一个元素 最后一个是0
	height := make([]int, len(matrix[0])+1)

	for i := 0; i < len(matrix); i++ {
		// 相加
		for j := 0; j < len(matrix[0]); j++ {
			// 高度要是一致连续的
			if matrix[i][j] != '0' {
				height[j] += int(matrix[i][j] - '0')
			} else {
				height[j] = 0
			}
		}

		// 单调栈
		stack := make([]int, 0)
		for j := 0; j < len(height); j++ {
			for len(stack) != 0 && height[stack[len(stack)-1]] > height[j] {
				// 要弹出的栈顶元素
				curr_height := height[stack[len(stack)-1]]

				// 右边界
				// curr_height在遍历到第i个的时候被弹出, 代表直到i-1都是比它大的
				right_border := j - 1

				// 弹出元素
				stack = stack[:len(stack)-1]

				//左边界, 如果stack没有元素, 代表一直向左都比这个大, 左边界可延伸
				left_border := 0
				if len(stack) != 0 {
					left_border = stack[len(stack)-1] + 1
				}

				if t := curr_height * (right_border - left_border + 1); t > res {
					res = t
				}
			}
			stack = append(stack, j)
		}
	}
	return res
}
```

## [155. 最小栈](https://leetcode.cn/problems/min-stack/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230725111347814.png" alt="image-20230725111347814" style="zoom:67%;" />

> 这不就是最大栈的反向操作吗>
>
> 并不一样啊, 这里面的元素可不能舍弃啊
>
> 
>
> 首先他得是一个栈, 这就和单调栈完全不同了

> 1 另起一个单调栈来进行记录, good
>
> 这样就结合了单调栈了 Good

```go
type MinStack struct {
	stack []int
	minS  []int
}

func Constructor() MinStack {
	return MinStack{minS: []int{}, stack: []int{}}
}

func (this *MinStack) Push(val int) {
	this.stack = append(this.stack, val)
	if len(this.minS) != 0 {
		if val <= this.minS[len(this.minS)-1] {
			this.minS = append(this.minS, val)
		}
	} else {
		this.minS = append(this.minS, val)
	}
}

func (this *MinStack) Pop() {
	p := this.stack[len(this.stack)-1]
	this.stack = this.stack[:len(this.stack)-1]
	if p <= this.minS[len(this.minS)-1] {
		this.minS = this.minS[:len(this.minS)-1]
	}
}

func (this *MinStack) Top() int {
	return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
	return this.minS[len(this.minS)-1]
}
```

> 可以在更新最小值的时候, 将原来的最小值入栈
>
> 这样当弹出的值为最小值的的时候, 下一个弹出的就是要更新的最小值
>
> 这样就实现了一个栈完成最小栈

> 这里的话，用了另一种思路。同样是用一个 min 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 min 值和栈顶元素得到，举个例子

```go
type MinStack struct {
	stack    []int
	minValue int
}

func Constructor() MinStack {
	return MinStack{minValue: 0, stack: []int{}}
}

func (this *MinStack) Push(val int) {
	if len(this.stack) == 0 {
		this.minValue = val
		this.stack = append(this.stack, val)
	} else {
		this.stack = append(this.stack, 0)
		if val < this.minValue {
			this.minValue = val // 更新最小值
		}
	}

}

func (this *MinStack) Pop() {
	p := this.stack[len(this.stack)-1]
	this.stack = this.stack[:len(this.stack)-1]
	if p < 0 {
		this.minValue -= p // 恢复大的最小值
	}
}

func (this *MinStack) Top() int {
	t := this.stack[len(this.stack)-1]
	if t < 0 {
		return this.minValue
	} else {
		return t + this.minValue
	}
}

func (this *MinStack) GetMin() int {
	return this.minValue
}
```

> 可以直接使用list来进行, 加一个MIN的值就ok

## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230808095549705.png" alt="image-20230808095549705" style="zoom:67%;" />

> - 注意是相邻的两个哈 => 直接使用栈

```go
func removeDuplicates(s string) string {
	stack := []byte{}
	for i := range s {
		if len(stack) > 0 && stack[len(stack)-1] == s[i] {
			stack = stack[:len(stack)-1]
		} else {
			stack = append(stack, s[i])
		}
	}
	return string(stack)
}
```

> 如果是相邻的全部删除呢>?>>>
>
> - 出栈的时候保存一个flag, 若是新的要入栈==flag, 就直接不入栈



## [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230831163257503.png" alt="image-20230831163257503" style="zoom:67%;" />

> 这个是最简单的单调站, 比矩形面积好太多了

```go
func dailyTemperatures(temperatures []int) []int {
	// 单调站
	stack := make([]int, 0)
	res := make([]int, len(temperatures))

	for i := 0; i < len(temperatures); i++ {
		if len(stack) != 0 {
			for len(stack) != 0 && temperatures[stack[len(stack)-1]] < temperatures[i] {
				res[stack[len(stack)-1]] = i - stack[len(stack)-1]
				stack = stack[:len(stack)-1]
			}
		}
		stack = append(stack, i)
	}

	fmt.Println(res)
	return res
}
```

## [856/90. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20231213103552679.png" alt="image-20231213103552679" style="zoom: 67%;" />

> - 使用递归肯定很好计算
> - 使用栈呢? => 括号就是栈的代名词啊
>   - 初始化将答案 `0` 放入栈中，从前往后处理整个 `s`，当遇到 `(` 则存入一个占位数值 `0`
>   - 遇到 `)` 取出栈顶元素 `cur`
>     - `cur` = 0 得分为1 存入栈 (但是要与前一个元素相加)
>     - 不等于0, 2*cur

```go
func scoreOfParentheses(s string) int {
	stack := make([]int, 1)

	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			stack = append(stack, 0)
		} else {
			cur := stack[len(stack)-1]
			pre_cur := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			if cur == 0 {
				stack = append(stack, 1+pre_cur)
			} else {
				stack = append(stack, 2*cur+pre_cur)
			}
		}
	}
	return stack[len(stack)-1]
}
```







# 队列



## [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230803223408304.png" alt="image-20230803223408304" style="zoom:67%;" />

> 两个队列就是一直交换
>
> 一个队列就是尾部移到前面

```go
type MyStack struct {
	queue []int
	cnt   int
}

func Constructor() MyStack {
	return MyStack{queue: []int{}}
}

func (this *MyStack) Push(x int) {
	this.cnt++
	this.queue = append(this.queue, x)
}

func (this *MyStack) Pop() int {
	for i := 0; i < this.cnt-1; i++ {
		this.queue = append(this.queue[1:], this.queue[0])
	}
	peek := this.queue[0]
	this.queue = this.queue[1:]
	this.cnt--
	return peek
}

func (this *MyStack) Top() int {
	return this.queue[len(this.queue)-1]
}

func (this *MyStack) Empty() bool {
	return this.cnt == 0
}
```







## [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230806000923022.png" alt="image-20230806000923022" style="zoom:67%;" />

```go
type MyQueue struct {
	s1  []int
	s2  []int // 直接入栈的
	cnt int
}

func Constructor() MyQueue {
	return MyQueue{s1: []int{}, s2: []int{}, cnt: 0}
}

func (this *MyQueue) Push(x int) {
	this.s2 = append(this.s2, x)

}

func (this *MyQueue) Pop() int {
	p := 0
	if len(this.s1) != 0 {
		p = this.s1[len(this.s1)-1]
		this.s1 = this.s1[:len(this.s1)-1]
	} else {
		for len(this.s2) != 0 {
			this.s1 = append(this.s1, this.s2[len(this.s2)-1])
			this.s2 = this.s2[:len(this.s2)-1]
		}
		p = this.s1[len(this.s1)-1]
		this.s1 = this.s1[:len(this.s1)-1]
	}
	return p
}

func (this *MyQueue) Peek() int {
	if len(this.s1) != 0 {
		return this.s1[len(this.s1)-1]
	} else {
		for len(this.s2) != 0 {
			this.s1 = append(this.s1, this.s2[len(this.s2)-1])
			this.s2 = this.s2[:len(this.s2)-1]
		}
		return this.s1[len(this.s1)-1]
	}
}

func (this *MyQueue) Empty() bool {
	return len(this.s1)+len(this.s2) == 0
}
```

## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230806223116525.png" alt="image-20230806223116525" style="zoom:67%;" />

> 单调队列呗
>
> 队列里面是由大到小的
>
> - 队头永远是最大的哈
> - 这个队列两端都是可以移除元素的!!!, 别被局限!!!

```go
type Queue struct {  // 创建一个队列
	queue []int
}

func (q *Queue) Push(elem int) {
	for len(q.queue) != 0 && q.queue[len(q.queue)-1] < elem { // 入队的必须是队里面的最大值
		q.queue = q.queue[:len(q.queue)-1] // 比他小的都从尾巴出来
	}
	q.queue = append(q.queue, elem) // 入队
}

func (q *Queue) Pop(elem int) {
	if len(q.queue) != 0 && q.queue[0] == elem { // 如果队头等于他, 出队
		q.queue = q.queue[1:]
	}
}

func maxSlidingWindow(nums []int, k int) []int {
	res := []int{}
	q := &Queue{queue: []int{}}
	for i := 0; i < k; i++ {
		q.Push(nums[i])
	}
	res = append(res, q.queue[0])
	for i := k; i < len(nums); i++ {
		q.Pop(nums[i-k])
		q.Push(nums[i])
		res = append(res, q.queue[0])
	}
	return res
}
```

## [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230904150903633.png" alt="image-20230904150903633" style="zoom:67%;" />

> - 两个单调队列
>   - 一个最大, 一个最小

```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        deque<int> qs, qb;
        int res {0}, left{0};
        for(int i=0; i<nums.size(); i++){
        	while(!qs.empty() && nums[qs.back()]>=nums[i]) qs.pop_back();
        	while(!qb.empty() && nums[qb.back()]<=nums[i]) qb.pop_back();
        	qs.push_back(i);
        	qb.push_back(i);
        	while(!qs.empty() && !qb.empty() && nums[qb.front()]-nums[qs.front()]>limit){
        		if(left==qb.front()) qb.pop_front();
        		if(left==qs.front()) qs.pop_front();
        		left ++;
        	}
        	res = max(res, i-left+1);
        }

        return res;	
    }
};
```

## [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230904151508215.png" alt="image-20230904151508215" style="zoom:67%;" />

> 前缀和 + 单调队列

```c++
class Solution {
public:
	using ll = long long;
    int shortestSubarray(vector<int>& nums, int k) {
        int n {static_cast<int>(nums.size())}; 
        int res {n+1};
        deque<int> dq;
        vector<ll> p{0};
        for(int i : nums) p.push_back(p.back()+i);
        for(int i=0; i<=n; i++){
        	while(!dq.empty() && p.at(dq.back())>p.at(i)) dq.pop_back();
        	while(!dq.empty() && p.at(i) - p.at(dq.front()) >=k){
        		res = min(res, i-dq.front());
        		dq.pop_front();
        	}
        	dq.push_back(i);
        }
        return res==n+1?-1:res;
    }
};
```



# 堆

## [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230717160323258.png" alt="image-20230717160323258" style="zoom:67%;" />

> 直接使用heap, contains/heap

```go
type nodes []*ListNode

func (n nodes) Len() int            { return len(n) }
func (n nodes) Less(i, j int) bool  { return n[i].Val < n[j].Val }
func (n nodes) Swap(i, j int)       { n[i], n[j] = n[j], n[i] }
func (n *nodes) Push(x interface{}) { *n = append(*n, x.(*ListNode)) }
func (n *nodes) Pop() interface{} {
	length := len(*n)
	x := (*n)[length-1]
	*n = (*n)[:length-1]
	return x
}

func mergeKLists(lists []*ListNode) *ListNode {
	ns := &nodes{}
	res := &ListNode{Val: 0, Next: nil}
	tmp := res
	for i := 0; i < len(lists); i++ {
		if lists[i] != nil {
			heap.Push(ns, lists[i])
		}
	}
	for len(*ns) != 0 {
		p := heap.Pop(ns).(*ListNode)
		if p.Next != nil {
			heap.Push(ns, p.Next)
		}
		p.Next = tmp.Next
		tmp.Next = p
		tmp = tmp.Next
	}
	return res.Next
}
```

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230718190832104.png" alt="image-20230718190832104" style="zoom:67%;" />

> 单调栈, 臭名昭著的接雨水, fuck
>
> 看完87再回来呗~~~

> 一根柱子能接多少水, 取决于它左边和它右边柱子的最大高度!!!!\
>
> 按列来计算
>
> 前缀+后缀的写法

```go
func trap(height []int) int {
	leftMax := make([]int, len(height))
	rightMax := make([]int, len(height))

	l, r := math.MinInt32, math.MinInt32
	for i := 0; i < len(height); i++ {
		if height[i] > l {
			l = height[i]
		}
		leftMax[i] = l
	}

	for i := len(height) - 1; i >= 0; i-- {
		if height[i] > r {
			r = height[i]
		}
		rightMax[i] = r
	}

	res := 0
	for i := 1; i < len(height)-1; i++ {
		if height[i] < max(leftMax[i], rightMax[i]) {
			res += min(leftMax[i], rightMax[i]) - height[i]
		}
	}
	return res
}
```

> 双指针写法 Good
>
> <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230718220231014.png" alt="image-20230718220231014" style="zoom:50%;" />
>
> 可以看到每一列的水位从两边向中间递增的

## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20230808101450075.png" alt="image-20230808101450075" style="zoom:67%;" />

> 很明显是使用优先队列(堆)啊
>
> - 就是自己要写接口, 很烦啊

```go
func topKFrequent(nums []int, k int) []int {
	occurrences := map[int]int{}
	for _, num := range nums {
		occurrences[num]++
	}
	h := &IHeap{}
	heap.Init(h)
	for key, value := range occurrences {
		heap.Push(h, [2]int{key, value})
		if h.Len() > k {
			heap.Pop(h)
		}
	}
	ret := make([]int, k)
	for i := 0; i < k; i++ {
		ret[k-i-1] = heap.Pop(h).([2]int)[0]
	}
	return ret
}

type IHeap [][2]int

func (h IHeap) Len() int            { return len(h) }
func (h IHeap) Less(i, j int) bool  { return h[i][1] < h[j][1] }
func (h IHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }
func (h *IHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
```

> 基于快速排序
>
> - 原版的快速排序算法的平均时间复杂度为 O(Nlog⁡N)。我们的算法中，每次只需在其中的一个分支递归即可，因此算法的平均时间复杂度降为 O(N)
> - 对于哈希表的结果进行快速排序, 去前k个,那么不要求顺序就与之前做过的一道题目一样了

```go
func topKFrequent(nums []int, k int) []int {
	// 先保存出现次数
	count := map[int]int{}
	// 数字, 出现次数
	values := [][]int{}
	for _, num := range nums {
		count[num] += 1
	}
	for key, value := range count {
		values = append(values, []int{key, value})
	}

	res := []int{}
	// 快排函数
	var qsort func(start, end, k int)
	qsort = func(start int, end int, k int) {
		// 获取一个随机索引值
		randIndex := rand.Intn(end-start+1) + start
		// 交换索引
		values[randIndex], values[start] = values[start], values[randIndex]
		//idx之前的都排好序了
		idx := start
		pivot := values[start][1]
		for i := start + 1; i <= end; i++ {
			if values[i][1] >= pivot {
				values[idx+1], values[i] = values[i], values[idx+1]
				idx += 1
			}
		}
		values[start], values[idx] = values[idx], values[start]
		if k == idx-start+1 {
			return
		} else if k > idx-start+1 {
			qsort(idx+1, end, k-(idx-start+1))
		} else {
			qsort(start, idx-1, k)
		}
	}

	qsort(0, len(values)-1, k)
	for i := 0; i < k; i++ {
		res = append(res, values[i][0])
	}
	return res
}
```



## [857/90 雇佣 K 名工人的最低成本](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/)

<img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20231213103222758.png" alt="image-20231213103222758" style="zoom:67%;" />

> - 在**最优**发工资方案下，至少有一名工人，发给他的工资恰好等于他的最低期望工资。
> - R = WAGE/QUALITY 每单位工作质量的工资
> - 若以 ri 为基准发工资，那么对于 r 值不超过 ri  的工人，发给他们的工资是不低于其最低期望工资的，因此这些工人是可以随意选择的。
> - r 从小到大排序, 则快速求出这些人
> - 这k人的质量之和为sumq, 那么他们的工资 sumq * ri
> - 使用最大堆维护quality, 这样后面来的r更大的, 去掉堆顶的元素, 入堆
>   - 更新res (如果结果可以的话)
> - <img src="./%E9%93%BE%E8%A1%A8-%E5%A0%86-%E9%98%9F%E5%88%97-%E6%A0%88.assets/image-20231213103510161.png" alt="image-20231213103510161" style="zoom: 50%;" />

```go
type node struct {
	r       float64
	quality float64
}

type pq []*node

func (t pq) Len() int {
	return len(t)
}

func (t *pq) Less(i, j int) bool {
	if (*t)[i].quality > (*t)[j].quality {
		return true
	} else if (*t)[i].quality == (*t)[j].quality {
		return (*t)[i].r < (*t)[j].r
	} else {
		return false
	}
}

func (t *pq) Swap(i, j int) {
	(*t)[i], (*t)[j] = (*t)[j], (*t)[i]
}

func (t *pq) Push(x interface{}) {
	*t = append(*t, x.(*node))
}

func (t *pq) Pop() interface{} {
	n := len(*t)
	x := (*t)[n-1]
	*t = (*t)[:n-1]
	return x
}

func mincostToHireWorkers(quality []int, wage []int, k int) float64 {
	// 单位质量的工资
	r := make([]*node, len(quality))
	for i := 0; i < len(quality); i++ {
		r[i] = &node{
			quality: float64(quality[i]),
			r:       float64(wage[i]) / float64(quality[i]),
		}
	}

	// 构建一个大顶堆, 先将前k人入堆
	// 先排序
	sort.Slice(r, func(i, j int) bool {
		if r[i].r < r[j].r {
			return true
		} else if r[i].r == r[j].r {
			return r[i].quality < r[j].quality
		}
		return false
	})

	// 构建堆
	h := &pq{}
	var res float64 = 0.0
	var currentQuality float64 = 0.0
	var currentR float64 = 0.0
	for i := 0; i < k; i++ {
		heap.Push(h, r[i])
		currentQuality += r[i].quality
		currentR = max(currentR, r[i].r)
	}
	res = currentR * currentQuality
	fmt.Println(res, currentR, currentQuality)

	// 继续入堆操作
	for i := k; i < len(r); i++ {
		currentR = r[i].r
		currentQuality = currentQuality - (*h)[0].quality + r[i].quality
		heap.Pop(h)
		heap.Push(h, r[i])
		res = min(res, currentR*currentQuality)
	}

	return res
}
```





















































