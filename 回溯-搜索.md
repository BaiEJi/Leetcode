## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230716150545566.png" alt="image-20230716150545566" style="zoom:67%;" />

> 回溯罢了
>
> string 与 byte 相加 应该将byte转为string
>
> 在Go里面写闭包函数, 真的比c++方便

```go
func letterCombinations(digits string) []string {
	strs := []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
	res := make([]string, 0)
	if len(digits) == 0 {
		return res
	}
	var dfs func(idx int, ret string)
	dfs = func(idx int, ret string) {
		if idx >= len(digits) {
			res = append(res, ret)
			return
		}
		for _, c := range strs[digits[idx]-uint8('0')] {
			ret = ret + string(c)
			dfs(idx+1, ret)
			ret = ret[:len(ret)-1]
		}
	}

	dfs(0, "")
	return res
}
```

## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230717093939148.png" alt="image-20230717093939148" style="zoom:67%;" />

> 可以优化

```go
if l != 0 {
    l -= 1
    s = s + "("
    // 已经-1, 传参就是l和r了
    dfs(l, r, s)
    s = s[:len(s)-1]
    l += 1
}

// 括号必须合规
if r != 0 && r > l {
    r -= 1
    s = s + ")"
    dfs(l, r, s)
    s = s[:len(s)-1]
    r += 1
}
```

```go
func generateParenthesis(n int) []string {
	var dfs func(int, int, string)
	res := make([]string, 0)
	dfs = func(l, r int, s string) {
		if l == 0 && r == 0 {
			res = append(res, s)
			return
		}
		if l != 0 {
			dfs(l-1, r, s+"(")
		}
		// 括号必须合规
		if r > l {
			dfs(l, r-1, s+")")
		}
	}
	dfs(n, n, "")
	return res
}
```

## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230718094056012.png" alt="image-20230718094056012" style="zoom:67%;" />

> dfs回溯
>
> 注意Golang在dfs中向认为数组append的浅拷贝问题

```go
func combinationSum(candidates []int, target int) [][]int {
	res := make([][]int, 0)
	tmpRes := make([]int, 0)
	// 创建回溯函数
	// idx代表从第几个数字开始
	var dfs func(idx int, sum int)
	dfs = func(idx int, sum int) {
		if sum > target {
			return
		} else if sum == target {
			// 必须这样, 要不然就拷贝指针了
			res = append(res, append([]int(nil), tmpRes...))
			return
		}

		for i := idx; i < len(candidates); i++ {
			tmpRes = append(tmpRes, candidates[i])
			dfs(i, sum+candidates[i])
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
	}

	dfs(0, 0)
	return res
}
```

## [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230718100442979.png" alt="image-20230718100442979" style="zoom:67%;" />

> 先排序, 这样选择就不需要使用集合来判断了
>
> 在同一个轮次中, 不能选一样的数字进行接下来的回溯
>
> 注意是i>idx 判断

```go
func combinationSum2(candidates []int, target int) [][]int {
	sort.Ints(candidates)	// 先排序
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	// 创建回溯函数
	// idx代表从第几个数字开始
	var dfs func(idx int, sum int)
	dfs = func(idx int, sum int) {
		if sum > target {
			return
		} else if sum == target {
			// 必须这样, 要不然就拷贝指针了
			res = append(res, append([]int(nil), tmpRes...))
			return
		}

		for i := idx; i < len(candidates); i++ {
			// 在同一轮次中, 同样位置的数字不能一样
			// 注意是大于idx不是大于0
			if i > idx && candidates[i] == candidates[i-1] {
				continue
			}
			tmpRes = append(tmpRes, candidates[i])
			dfs(i+1, sum+candidates[i])
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
	}

	dfs(0, 0)
	return res
}
```

## [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230802204311767.png" alt="image-20230802204311767" style="zoom:67%;" />

> 回溯gogogo

```go
func combinationSum3(k int, n int) [][]int {
	var res [][]int
	var tmpRes []int
	var dfs func(currentSum int, start int)
	dfs = func(currentSum int, start int) {
		if currentSum == n && len(tmpRes) == k {
			res = append(res, append([]int(nil), tmpRes...))
			return
		}
		if currentSum > n || len(tmpRes) == k {
			return
		}
		for i := start; i <= 9; i++ {
			tmpRes = append(tmpRes, i)
			dfs(currentSum+i, i+1)
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
	}
	dfs(0, 1)
	return res
}
```







## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230718143540417.png" alt="image-20230718143540417" style="zoom:67%;" />

> 难点在于
>
> - 使用了三个哈希表数组
> - dfs传入idx而不是分别传入row, column, 这样更好计算
> - 因为是要返回原来的board, 所以dfs要是用bool返回值, 快速失败!!!\
> - 一定不要忘记最后写一个dfs(0)!!!!!!!!!!!!

```go
func solveSudoku(board [][]byte) {
	// 创建字典并初始化
	mapRow := make([]map[byte]int, 9)
	mapColumn := make([]map[byte]int, 9)
	mapBlock := make([]map[byte]int, 9)
	for i := 0; i < 9; i++ {
		mapRow[i] = make(map[byte]int)
		mapColumn[i] = make(map[byte]int)
		mapBlock[i] = make(map[byte]int)
	}

	// 读取棋盘
	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			if board[i][j] != '.' {
				mapRow[i][board[i][j]] = 1
				mapColumn[j][board[i][j]] = 1
				mapBlock[i/3*3+j/3][board[i][j]] = 1
			}
		}
	}

	// dfs
	var dfs func(idx int) bool
	dfs = func(idx int) bool {
		if idx == 81 {
			fmt.Println(board)
			return true
		}
		row, column := idx/9, idx%9
		if board[row][column] != '.' {
			if dfs(idx + 1) {
				return true
			} else {
				return false
			}
		} else {
			for i := 1; i <= 9; i++ {
				if mapRow[row][byte(i+'0')] == 0 && mapColumn[column][byte(i+'0')] == 0 && mapBlock[row/3*3+column/3][byte(i+'0')] == 0 {
					board[row][column] = byte(i + '0')
					mapRow[row][byte(i+'0')] = 1
					mapColumn[column][byte(i+'0')] = 1
					mapBlock[row/3*3+column/3][byte(i+'0')] = 1
					if dfs(idx + 1) {
						return true
					}
					mapRow[row][byte(i+'0')] = 0
					mapColumn[column][byte(i+'0')] = 0
					mapBlock[row/3*3+column/3][byte(i+'0')] = 0
					board[row][column] = '.'
				}
			}
			return false
		}
	}
	dfs(0)
}
```

## [46. 全排列](https://leetcode.cn/problems/permutations/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230718165248824.png" alt="image-20230718165248824" style="zoom:67%;" />

> easy
>
> 这个dfs因为Golang中闭包的原因, 所以是不需要参数的

```go
func permute(nums []int) [][]int {
	res := make([][]int, 0)
	tmpRes := make([]int, 0)
	m := make(map[int]int)

	var dfs func()
	dfs = func() {
		if len(tmpRes) == len(nums) {
			res = append(res, append([]int(nil), tmpRes...))
			return
		}
		for i := 0; i < len(nums); i++ {
			if m[nums[i]] == 0 {
				m[nums[i]] = 1
				tmpRes = append(tmpRes, nums[i])
				dfs()
				m[nums[i]] = 0
				tmpRes = tmpRes[:len(tmpRes)-1]
			}
		}
	}
	dfs()
	return res
}
```

## [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230718165033750.png" alt="image-20230718165033750" style="zoom:67%;" />

> 难点就在于如何去重.....
>
> - 先sort 让一样的数字挨在一起
> - 然后判断当前一个和自己一样的话, 前一个必须已经被取到了
> - 这样的话就需要一个map

```go
func permuteUnique(nums []int) [][]int {
	sort.Ints(nums)
	res := make([][]int, 0)
	tmpRes := make([]int, 0)
	m := make(map[int]int)

	var dfs func()
	dfs = func() {
		if len(tmpRes) == len(nums) {
			res = append(res, append([]int(nil), tmpRes...))
			return
		}
		for i := 0; i < len(nums); i++ {
			if i > 0 && nums[i] == nums[i-1] && m[i-1] == 0 {
				continue // 去重, 一样的数字从前面开始读取
			}
			if m[i] == 0 {
				m[i] = 1
				tmpRes = append(tmpRes, nums[i])
				dfs()
				m[i] = 0
				tmpRes = tmpRes[:len(tmpRes)-1]
			}
		}
	}
	dfs()
	return res
}
```



## [51. N 皇后](https://leetcode.cn/problems/n-queens/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230719092500069.png" alt="image-20230719092500069" style="zoom:67%;" />

> 开始回溯
>
> 难点在于怎么设计结果的表示, 在golang中可不简单
>
> 回溯回的是第几行方第几个位置
>
> 
>
> 按照行来回溯:
>
> - 可以免去行相同的判断
> - 可以免去列相同的判断(记录了used哈希)
> - 只需要根据列表中的下标判断是否在对角线上就行了
> - 只有真正有效的进行回溯

```go
func solveNQueens(n int) [][]string {
	// 创建一个返回的二维矩阵
	res := make([][]string, 0, n)
	// 表示第i行用的是第几个
	pos := make([]int, 0)
	// 第几个用过了没有
	used := make(map[int]int)

	var dfs func(idx int)
	dfs = func(idx int) {
		if idx >= n {
			// 保存一个结果
			resTmp := make([]string, 0, n)
			for i := 0; i < n; i++ {
				var buff bytes.Buffer
				for j := 0; j < n; j++ {
					if j == pos[i] {
						buff.WriteByte('Q')
					} else {
						buff.WriteByte('.')
					}
				}
				resTmp = append(resTmp, buff.String())
			}
			res = append(res, resTmp)
			return
		}

		for i := 0; i < n; i++ {
			// 这一列没有使用过
			if used[i] == 0 {
				flag := false
				for j := 0; j < len(pos); j++ {
					if abs(idx-j) == abs(i-pos[j]) {
						// 对角线不行
						flag = true
						break
					}
				}
				// 对角线不行, 就不能让它继续进行
				// 只有真正有效的进行回溯
				if flag {
					continue
				}
				// 可以选用这个
				used[i] = 1
				pos = append(pos, i)
				dfs(idx + 1)
				pos = pos[:len(pos)-1]
				used[i] = 0
			}
		}
	}
	dfs(0)
	return res
}
```

## [52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

> 返回数量, 没啥区别

```go
func totalNQueens(n int) int {
	res := 0
	// 表示第i行用的是第几个
	pos := make([]int, 0)
	// 第几个用过了没有
	used := make(map[int]int)

	var dfs func(idx int)
	dfs = func(idx int) {
		if idx >= n {
			res += 1
			return
		}

		for i := 0; i < n; i++ {
			// 这一列没有使用过
			if used[i] == 0 {
				flag := false
				for j := 0; j < len(pos); j++ {
					if abs(idx-j) == abs(i-pos[j]) {
						// 对角线不行
						flag = true
						break
					}
				}
				// 对角线不行, 就不能让它继续进行
				// 只有真正有效的进行回溯
				if flag {
					continue
				}
				// 可以选用这个
				used[i] = 1
				pos = append(pos, i)
				dfs(idx + 1)
				pos = pos[:len(pos)-1]
				used[i] = 0
			}
		}
	}
	dfs(0)
	return res
}

func abs(i int) int {
	if i < 0 {
		return -i
	}
	return i
}
```

## [60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230719120331086.png" alt="image-20230719120331086" style="zoom:67%;" />

> 看似和全排列差不多, 回溯就ok
>
> - 是1-n的排列, 肯定是要找规律的
> - 而且n太大的话, 会造成层数过多, 导致失败, 而且会很慢
> - 而且回溯优化的话, 也是时间很大

```go
func getPermutation(n int, k int) string {
	nums := make([]int, 0, n)
	for i := 1; i <= n; i++ {
		nums = append(nums, i)
	}
	idx := 0
	var res string

	tmpRes := make([]int, 0)
	m := make(map[int]int)

	var dfs func()
	dfs = func() {
        // 提前终止, 节约时间
		if idx >= k {
			return
		}
		if len(tmpRes) == len(nums) {
            // 设定返回值
			idx += 1
			if idx == k {
				var buff bytes.Buffer
				for _, i := range tmpRes {
					buff.WriteByte(byte('0' + i))
				}
				res = buff.String()
			}
			return
		}
        // 进行回溯
		for i := 0; i < len(nums); i++ {
			if i > 0 && nums[i] == nums[i-1] && m[i-1] == 0 {
				continue // 去重, 一样的数字从前面开始读取
			}
			if m[i] == 0 {
				m[i] = 1
				tmpRes = append(tmpRes, nums[i])
				dfs()
				m[i] = 0
				tmpRes = tmpRes[:len(tmpRes)-1]
			}
		}
	}
	dfs()
	return res
}
```

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230719122216357.png" alt="image-20230719122216357" style="zoom:67%;" />

> 但是之前已经使用过的数字不能再使用, 如何计算相对位置
>
> => 把数组中的数字剔除就ok了

```go
func getPermutation(n int, k int) string {
	// 构建阶乘数组
	factorial := make([]int, n)
	factorial[0] = 1
	for i := 1; i < n; i++ {
		factorial[i] = factorial[i-1] * i
	}
    
    // 从0开始计算的k
	k -= 1

	// 结果
	res := ""

    // 保存用过那些数字
	valid := make([]int, n+1)
	for i := 0; i < len(valid); i++ {
		valid[i] = i + 1
	}

	for i := 0; i < n; i++ {
		order := k / factorial[n-i-1]
        // 保存数字
		res += strconv.Itoa(valid[order])
        // 删除数字
		valid = append(valid[:order], valid[order+1:]...)
		k %= factorial[n-i-1]
	}
	return res
}
```

### 康拓展开和逆展开

> 康托展开是一个[全排列](https://so.csdn.net/so/search?q=全排列&spm=1001.2101.3001.7020)到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是在n个不同元素的全排列中, 比当前排列组合小的个数，那么也可以表示当前排列组合在n个不同元素的全排列中的名次（当前的名次 = 比当前排列组合小的个数 + 1）。

$X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!$

*ai*代表的是从右往左数比当前这个数字小的并且没有出现过的数字个数。

如：12345求39大的排列
∵  从0开始计数，我们就是开始从38开始算

38/4! = 1…14 ,{1， 2， 3， 4， 5}你要选一个数出来只有一个比它小的数所以第一位我们选2。
14/3！= 2…2，{1, 3, 4, 5}，你要选一个数出来只有一个比它小的数所以第二位我们选4。
2/2! = 1…0, {1, 3, 5}, 你要选一个数出来只有一个比它小的数所以第三位我们选3。
0/1! = 0…0，{1, 5}，你要选一个数出来没有一个比它小的数所以第四位我们选1。

## [78. 子集](https://leetcode.cn/problems/subsets/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230721085643154.png" alt="image-20230721085643154" style="zoom:67%;" />

> 回溯, 要么选, 要么不选

```go
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	var dfs func(idx int)
	dfs = func(idx int) {
		if idx == len(nums) {
			res = append(res, append([]int(nil), tmpRes...))
			return
        }
		// 在这就不用循环啦
		// 不选
		dfs(idx + 1)
		// 选
		tmpRes = append(tmpRes, nums[idx])
		dfs(idx + 1)
		tmpRes = tmpRes[:len(tmpRes)-1]
	}
	dfs(0)
	return res
}
```

```go
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	var dfs func(idx int)
	dfs = func(idx int) {
		res = append(res, append([]int(nil), tmpRes...))
		for i := idx; i < len(nums); i++ {
			tmpRes = append(tmpRes, nums[i])
			dfs(i + 1)
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
	}
	dfs(0)
	return res
} // 这种写法更好地!!!!!
```



## [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230722131603755.png" alt="image-20230722131603755" style="zoom:67%;" />

> 如果和前一个相同, 选这个必须的选到前边那个才行

```go
func subsetsWithDup(nums []int) [][]int {
	sort.Ints(nums)
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	var dfs func(idx int, prev bool)
	dfs = func(idx int, prev bool) {
		// 到最后保存结果
		if idx >= len(nums) {
			res = append(res, append([]int(nil), tmpRes...))
			return
		}
		// 这个不可以选, 但是不选他还可以继续向下遍历
		if idx > 0 && nums[idx] == nums[idx-1] && prev == false {
			dfs(idx+1, false)
		} else {
			// 这个可以选, 那么选和不选自己决定
			dfs(idx+1, false)
			tmpRes = append(tmpRes, nums[idx])
			dfs(idx+1, true)
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
	}

	dfs(0, false)
	return res
}
```

> 还有一种回溯方法
>
> - 我的go的写法是不在dfs里面循环的, 只会一层层往下
> - 另一种写法, 还就是在回溯里面集上循环
>
> **一个结果的前一部分一定也是结果!!!**!
>
> 这种比我写的感觉更妙啊啊啊啊啊啊!!!!!
>
> Good

```go
func subsetsWithDup(nums []int) [][]int {
	sort.Ints(nums)
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	var dfs func(idx int)
	dfs = func(idx int) {
		res = append(res, append([]int(nil), tmpRes...))
		for i := idx; i < len(nums); i++ {
			if i != idx && nums[i] == nums[i-1] {
				continue
			}
			tmpRes = append(tmpRes, nums[i])
			dfs(i + 1)
			tmpRes = tmpRes[:len(tmpRes)-1]
		}
		return
	}
	dfs(0)
	return res
}
```

## [77. 组合](https://leetcode.cn/problems/combinations/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230721090847764.png" alt="image-20230721090847764" style="zoom:67%;" />

> 做一个提前结束的剪枝
>
> 要不然太慢了
>
> 闭包少穿参数 Good!!!

```go
func combine(n int, k int) [][]int {
	res := make([][]int, 0)
	tmpRes := make([]int, 0)

	var dfs func(idx int)
	dfs = func(idx int) {
		// 后面的不够选了
		if n-idx+1+len(tmpRes) < k {
			return
		}
        // 已经选完了
		if len(tmpRes) == k {
			res = append(res, append([]int(nil), tmpRes...))
			return
		}
		if idx > n {
			return
		}

		dfs(idx + 1)
		tmpRes = append(tmpRes, idx)
		dfs(idx + 1)
		tmpRes = tmpRes[:len(tmpRes)-1]
	}
	dfs(1)
	return res
}
```

## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230721094318188.png" alt="image-20230721094318188" style="zoom:67%;" />

> dfs查找呗
>
> 注意超出范围的判断条件放在dfs的起始处, 这样代码书写更easy
>
> 注意的一点是, 不能重复使用, 访问一个要设为一个dummy值

```go
func exist(board [][]byte, word string) bool {
	m, n, w := len(board), len(board[0]), len(word)

	var dfs func(i, j, idx int) bool
	dfs = func(i, j, idx int) bool {
		// 0-w-1 都已经匹配到啦
		if idx >= w {
			return true
		}

		// 应该继续匹配但是索引不对
		if i < 0 || j < 0 || i >= m || j >= n {
			return false
		}

		// 这个字符可以匹配
		if board[i][j] == word[idx] {
			// 一个字符只能用一遍
			tmpChar := board[i][j]
			board[i][j] = '#'
			// 返回四周的至少有一个匹配
			if dfs(i-1, j, idx+1) || dfs(i, j-1, idx+1) || dfs(i+1, j, idx+1) || dfs(i, j+1, idx+1) {
				return true
			}
			board[i][j] = tmpChar
		}
		return false
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if board[i][j] == word[0] {
				if dfs(i, j, 0) {
					return true
				}
			}
		}
	}
	return false
}
```



## [89. 格雷编码](https://leetcode.cn/problems/gray-code/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230722130055121.png" alt="image-20230722130055121" style="zoom:67%;" />

> n==1  [0, 1]
>
> n > 1  0+f(n-1) and 1+reverse(f(n-1))   
>
> 编码是有规律的, 找到规律就ok
>
> Good

```go
func grayCode(n int) []int {
	if n == 1 {
		return []int{0, 1}
	}

	res := make([]int, 0)
	tmp := grayCode(n - 1)
	for i := 0; i < len(tmp); i++ {
		res = append(res, tmp[i])
	}

	for i := len(tmp) - 1; i >= 0; i-- {
		res = append(res, int(math.Pow(2, float64(n)-1))+tmp[i])
	}
	return res
}
```

> $G(i) = i  异或  (i/2)$
>
> ` for(int i = 0; i < 1<<n; ++i)`

```go
func grayCode(n int) []int {
	res := make([]int, 0)
	for i := 0; i < 1<<n; i++ {
		res = append(res, i^i>>1)
	}
	return res
}
```

## [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230722134413263.png" alt="image-20230722134413263" style="zoom:67%;" />

> 回溯呗  会时间超限!!!!!!!!!!!!
>
> 有一点边界条件

```go
// 时间超限!!!!!!!!!!!!!!!!!!!!!!!
func numDecodings(s string) int {
	res, l := 0, len(s)

	var dfs func(idx int)
	dfs = func(idx int) {
		if idx >= l {
			res += 1
			return
		}
		
		if int(s[idx]-'0') == 0 {
			return
		}

		if int(s[idx]-'0') > 0 {
			dfs(idx + 1)
		}
		if idx < l-1 {
			tmp, _ := strconv.Atoi(s[idx : idx+2])
			if tmp > 0 && tmp <= 26 {
				dfs(idx + 2)
			}
		}
	}
	dfs(0)
	return res
}
```

> 需要DP才可以的!!!!!!!!!!!!!!!
>
> 
>
> s[i] != 0 s[i]+=s[i-1]
>
> s[i-1:i+1] s[i] += s[i-2]
>
> 
>
> dp 长度 n+1
>
> dp[0] = 1 空字符串有一种解码方式

```go
func numDecodings(s string) int {
	dp := make([]int, len(s)+1, len(s)+1)
	dp[0] = 1
	for i := 1; i < len(dp); i++ {
		if int(s[i-1]-'0') > 0 {
			dp[i] += dp[i-1]
		}

		if i >= 2 {
			t, _ := strconv.Atoi(s[i-2 : i])
			// 二位数不可以以0开头
			if t >= 10 && t <= 26 {
				dp[i] += dp[i-2]
			}
		}
	}
	return dp[len(dp)-1]
}
```

## [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230722141447598.png" alt="image-20230722141447598" style="zoom:67%;" />

> 回溯呗

```go
func restoreIpAddresses(s string) []string {
	res := make([]string, 0)
	tmpRes := make([]string, 0)
	ls := len(s)

	var dfs func(idx int)
	dfs = func(idx int) {
        // 满足条件
		if idx >= ls {
			if len(tmpRes) == 4 {
				res = append(res, strings.Join(tmpRes, "."))
			}
			return
		}

		// 长度超了
		if len(tmpRes) == 4 {
			return
		}

		// 一位
		tmpRes = append(tmpRes, s[idx:idx+1])
		dfs(idx + 1)
		tmpRes = tmpRes[:len(tmpRes)-1]

		// 两位, 三位
		if s[idx] != '0' {
			// 两位
			if idx < ls-1 {
				tmpRes = append(tmpRes, s[idx:idx+2])
				dfs(idx + 2)
				tmpRes = tmpRes[:len(tmpRes)-1]
			}
			// 三位
			if idx < ls-2 {
				if t, _ := strconv.Atoi(s[idx : idx+3]); t <= 255 {
					tmpRes = append(tmpRes, s[idx:idx+3])
					dfs(idx + 3)
					tmpRes = tmpRes[:len(tmpRes)-1]
				}
			}
		}

	}
	dfs(0)
	return res
}
```

## [95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230723000506842.png" alt="image-20230723000506842" style="zoom:67%;" />

> 肯定是回溯
>
> 只是这个更特殊, 要自己构建BST, 题解比我想象的简单多了
>
> - 左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此我们可以想到用回溯的方法来解决这道题目。
> - 我们定义 generateTrees(start, end) 函数表示当前值的集合为 $[\textit{start},\textit{end}]$，返回序列$[start,end]$生成的所有可行的二叉搜索树。
> - 递归的入口即为 `generateTrees(1, n)`
> - 出口为当 $\textit{start}>\textit{end}$ 的时候，当前二叉搜索树为空，返回空节点即可。

```go
func generateTrees(n int) []*TreeNode {
	if n == 0 {
		return nil
	}
	var dfs func(start, end int) []*TreeNode
	dfs = func(start, end int) []*TreeNode {
		// 回溯终止
		if start > end {
			return []*TreeNode{nil}
		}
		// 这个的所有的树的集合
		allTrees := []*TreeNode{}
		// 枚举可行根节点
		for i := start; i <= end; i++ {
			// 获得所有可行的左子树集合
			leftTrees := dfs(start, i-1)
			// 获得所有可行的右子树集合
			rightTrees := dfs(i+1, end)
			// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
			for _, left := range leftTrees {
				for _, right := range rightTrees {
					currTree := &TreeNode{i, nil, nil}
					currTree.Left = left
					currTree.Right = right
					allTrees = append(allTrees, currTree)
				}
			}
		}
		return allTrees
	}
	return dfs(1, n)
}
```

## [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230809110348176.png" alt="image-20230809110348176" style="zoom:67%;" />

> 判断求得是节点还是叶子, 是节点
>
> - 所以再每次进入回溯函数的时候, 就直接保存结果 !!!!!!!!!!!!!!
>
> 难点在于去重 1 x 1 1 1 1
>
> - 这样可能直接会有两个 1 1 1 1的结果
> - 对于一层来说, 一个数字只可以使用一次

```go
func findSubsequences(nums []int) [][]int {
	var res [][]int
	var tmpRes []int

	var dfs func(start int)
	dfs = func(start int) {
		if len(tmpRes) >= 2 {
			res = append(res, append([]int(nil), tmpRes...))
		}

		used := map[int]bool{}

		for i := start; i < len(nums); i++ {
			if len(tmpRes) != 0 && nums[i] < tmpRes[len(tmpRes)-1] {
				continue
			}
			if used[nums[i]] {
				continue
			}
			used[nums[i]] = true
			tmpRes = append(tmpRes, nums[i])
			dfs(i + 1)
			tmpRes = tmpRes[:len(tmpRes)-1]

		}
	}
	dfs(0)
	return res
}
```

## [679. 24 点游戏](https://leetcode.cn/problems/24-game/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230809113513465.png" alt="image-20230809113513465" style="zoom:67%;" />

> 在每个循环里面创建副本, 以免出错

```go
func judgePoint24(cards []int) bool {
	// 转为浮点数
	cardsFloat := []float64{}
	for _, card := range cards {
		cardsFloat = append(cardsFloat, 1.0*float64(card))
	}
	res := false

	var dfs func(cards []float64)
	dfs = func(cards []float64) {
		// 快速结束
		if res {
			return
		}

		// 判断一个结果
		if len(cards) == 1 {
			if math.Abs(24-cards[0]) < 0.00001 {
				res = true
			}
			return
		}

		for i := 0; i < len(cards); i++ {
			for j := i + 1; j < len(cards); j++ {
				// 创建副本
				cardsCopy := make([]float64, len(cards))
				copy(cardsCopy, cards)
				cardsCopy = append(cardsCopy[:i], append(cardsCopy[i+1:j], cardsCopy[j+1:]...)...)

				dfs(append(cardsCopy, cards[i]+cards[j])) // 加法
				dfs(append(cardsCopy, cards[i]-cards[j]))
				dfs(append(cardsCopy, cards[j]-cards[i]))
				dfs(append(cardsCopy, cards[i]*cards[j]))
				if math.Abs(0-cards[j]) > 0.00001 { // 除法
					dfs(append(cardsCopy, cards[i]/cards[j]))
				}
				if math.Abs(0-cards[i]) > 0.00001 {
					dfs(append(cardsCopy, cards[j]/cards[i]))
				}
			}
		}
	}
	dfs(cardsFloat)
	return res
}
```









# 字符串的

> 一般来说, 字符串的操作都以dp居多, 因为回溯很容易超时
>
> 但是对于长度较短的, 完全可以回溯

## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230724232844713.png" alt="image-20230724232844713" style="zoom:67%;" />

> 回溯呗
>
> 而且结果要求返回具体的分割结果, 这样一般都是回溯
>
> 只返回方案数目的一般都是dp

```go
func partition(s string) [][]string {
	// 判断回文串
	isSym := func(s string) bool {
		l, r := 0, len(s)-1
		for l < r {
			if s[l] != s[r] {
				return false
			}
			l, r = l+1, r-1
		}
		return true
	}
	var res [][]string
	var resTmp []string

	var dfs func(startIdx int)
	dfs = func(startIdx int) {
		if startIdx == len(s) {
			res = append(res, append([]string(nil), resTmp...))
		}
		for i := startIdx; i < len(s); i++ {
			if isSym(s[startIdx : i+1]) {
				resTmp = append(resTmp, s[startIdx:i+1])
				dfs(i + 1)
				resTmp = resTmp[:len(resTmp)-1]
			}
		}
	}
	dfs(0)
	return res
}
```

## [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230725172502754.png" alt="image-20230725172502754" style="zoom:67%;" />

> 要求返回救过, 那就是回溯了
>
> join函数挺好用的

```go
func wordBreak(s string, wordDict []string) []string {
	res := make([]string, 0)
	tmpRes := make([]string, 0)
	ls := len(s)

	var dfs func(startIdx int)
	dfs = func(startIdx int) {
		if startIdx >= ls {
			res = append(res, strings.Join(tmpRes, " "))
			return
		}

		for _, word := range wordDict {
			if ls-startIdx < len(word) {
				continue
			}
			if s[startIdx:startIdx+len(word)] == word {
				tmpRes = append(tmpRes, word)
				dfs(startIdx + len(word))
				tmpRes = tmpRes[:len(tmpRes)-1]
			}
		}
	}
	dfs(0)
	return res
}
```





## [842/86. 将数组拆分成斐波那契序列](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20231205000329711.png" alt="image-20231205000329711" style="zoom:80%;" />

> 直接回溯
>
> - 这个方法是动态修改外部的res, 如何保证之前正确的临时结果不被之后的回溯修改呢?
>   - dfs返回bool来进行修饰, dfs返回true,那就不pop尾部就行啦!!!!!!!!!!!!!!!
> - 一定要记得dfs(0)呀!!!!!!!!!!!,可不能忘啊

```go
func splitIntoFibonacci(num string) []int {
	res := make([]int, 0)
	ret := make([]int, 0)

	var dfs func(start int)
	dfs = func(start int) {
		if start == len(num) { // 复杂的临时结果保存.........
			if len(res) > len(ret) {
				ret = []int{}
				ret = append(ret, res...)
			}
			return
		}

		if num[start] == '0' {
			if len(res) < 2 || (len(res) >= 2 && res[len(res)-1]+res[len(res)-2] == 0) {
				res = append(res, 0)
				dfs(start + 1)
				res = res[:len(res)-1]
			}
		} else {
			if len(res) < 2 {
				for end := start; end < len(num); end++ {
					tmp, _ := strconv.ParseInt(num[start:end+1], 10, 0)
					if tmp > math.MaxInt32 {
						break
					} else {
						res = append(res, int(tmp))
						dfs(end + 1)
						res = res[:len(res)-1]
					}
				}
			} else {
				for end := start; end < len(num); end++ {
					tmp, _ := strconv.ParseInt(num[start:end+1], 10, 0)
					if tmp > int64(res[len(res)-1]+res[len(res)-2]) {
						break
					} else if tmp <= math.MaxInt32 && tmp == int64(res[len(res)-1]+res[len(res)-2]) {
						res = append(res, int(tmp))
						dfs(end + 1)
						res = res[:len(res)-1]
					}
				}

			}
		}
	}
	dfs(0)
	if len(ret) < 3 {
		return nil
	}
	return ret
}
```

```go
func splitIntoFibonacci(num string) []int {
	res := make([]int, 0)

	var dfs func(start int) bool
	dfs = func(start int) bool {
		if start == len(num) && len(res) >= 3 {
			return true // true才是真正有用的
		}

		for end := start; end < len(num); end++ {
			tmp, _ := strconv.ParseInt(num[start:end+1], 10, 0)
			if end > start && num[start] == '0' {
				break
			} else if tmp <= math.MaxInt32 && (len(res) < 2 || tmp == int64(res[len(res)-1]+res[len(res)-2])) {
				res = append(res, int(tmp))
				if dfs(end + 1) { // 直接返回, 不pop尾部了
					return true
				}
				res = res[:len(res)-1]
			}
		}
		return false
	}
	dfs(0)
	return res
}
```



































# 并查集

## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230724223528081.png" alt="image-20230724223528081" style="zoom:67%;" />

> 哈希表也是可以做到的, 只是直接遍历哈希表, 从[num-1]不在哈希表里面的开始向高处遍历. 遍历完更新就ok啦
>
> 其实就是从每一个起点开始遍历
>
> 这样是O(N), 而排序再判断起点是nlogn . 这点要注意, 哈希表可以直接判断

```go
func longestConsecutive(nums []int) int {
	numSet := map[int]bool{}
	for _, num := range nums {
		numSet[num] = true
	}
	longestStreak := 0
	for num := range numSet {
		if !numSet[num-1] {
			currentNum := num
			currentStreak := 1
			for numSet[currentNum+1] {
				currentNum++
				currentStreak++
			}
			if longestStreak < currentStreak {
				longestStreak = currentStreak
			}
		}
	}
	return longestStreak
}
```

> 写一个并查集模板把
>
> - 只不过这道题的并查集是一个哈希表, 而不是常规的数组

```go
type Bset struct {
	root map[int]int
}

func NewBset() *Bset {
	bset := &Bset{}
	bset.root = make(map[int]int)
	return bset
}

func (b *Bset) find(x int) int {
	if _, ok := b.root[x]; !ok {
		return math.MinInt
	}
	if x != b.root[x] {
		b.root[x] = b.find(b.root[x])
	}
	return b.root[x]
}

func (b *Bset) union2(x, y int) {
	xr, yr := b.find(x), b.find(y)
	if xr == yr {
		return
	}
	b.root[xr] = yr
}

func (b *Bset) connected(x, y int) bool {
	return b.find(x) == b.find(y)
}
```

```go
func longestConsecutive(nums []int) int {
	bset := NewBset()
	for _, num := range nums {
		bset.root[num] = num
	}

	res := 0
	for _, num := range nums {
		if bset.find(num+1) != math.MinInt {
            // 把和它大1的连接
			bset.union2(num, num+1)
		}
	}
	for _, num := range nums {
        // 每个都只指向这一串中最大的
		res = max(res, bset.find(num)-num+1)
	}
	return res
}
```



## [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810125750723.png" alt="image-20230810125750723" style="zoom:67%;" />

> 在已经相互连接的两个节点上, 又连了一次

```go
type Bset struct {
	root   []int
	length int
}

func NewBset(length int) *Bset {
	bset := &Bset{length: length}
	bset.root = make([]int, length)
	for i := 0; i < length; i++ {
		bset.root[i] = i
	}
	return bset
}

func (b *Bset) find(x int) int {
	if x != b.root[x] {
		b.root[x] = b.find(b.root[x])
	}
	return b.root[x]
}

func (b *Bset) union2(x, y int) {
	xr, yr := b.find(x), b.find(y)
	if xr == yr {
		return
	}
	b.root[xr] = yr
}

func (b *Bset) connected(x, y int) bool {
	return b.find(x) == b.find(y)
}

func findRedundantConnection(edges [][]int) []int {
	bset := NewBset(len(edges)+1)
	for _, edge := range edges {
		if bset.connected(edge[0], edge[1]) {
			return edge
		}
		bset.union2(edge[0], edge[1])
	}
	return nil
}
```

## [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810132140328.png" alt="image-20230810132140328" style="zoom:67%;" />

> <img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810132313425.png" alt="image-20230810132313425" style="zoom:67%;" />
>
> <img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810132325944.png" alt="image-20230810132325944" style="zoom:67%;" />
>
> 
>
> - 这题就是情况都想明白就好了

```go
type Bset struct {
	root   []int
	length int
}

func NewBset(length int) *Bset {
	bset := &Bset{length: length}
	bset.root = make([]int, length)
	for i := 0; i < length; i++ {
		bset.root[i] = i
	}
	return bset
}

func (b *Bset) find(x int) int {
	if x != b.root[x] {
		b.root[x] = b.find(b.root[x])
	}
	return b.root[x]
}

func (b *Bset) union2(x, y int) {
	xr, yr := b.find(x), b.find(y)
	if xr == yr {
		return
	}
	b.root[xr] = yr
}

func (b *Bset) connected(x, y int) bool {
	return b.find(x) == b.find(y)
}

func findRedundantDirectedConnection (edges [][]int) []int {
	// 记录节点的入度
	inDegree := map[int]int{}
	n := len(edges)
	for i := 0; i < n; i++ {
		inDegree[edges[i][1]]++
	}

	inDegreeEqual2 := []int{} // 记录入度为2的边
	// 倒序, 因为要返回最后出现的
	for i := n - 1; i >= 0; i-- {
		if inDegree[edges[i][1]] == 2 {
			inDegreeEqual2 = append(inDegreeEqual2, i)
		}
	}

	// 如果有入度为2的, 删除一条看看能否构成树
	isTreeAfterRemoveEdge := func(deleteEdge int) bool {
		bset := NewBset(n + 1)
		for i := 0; i < n; i++ {
			if i == deleteEdge {
				continue
			}
			if bset.connected(edges[i][0], edges[i][1]) {
				return false
			}
			bset.union2(edges[i][0], edges[i][1])
		}
		return true
	}
	if len(inDegreeEqual2) > 0 {
		// 肯定是只有两个
		if isTreeAfterRemoveEdge(inDegreeEqual2[0]) {
			return edges[inDegreeEqual2[0]]
		} else {
			return edges[inDegreeEqual2[1]]
		}
	}

	// 有向环
	bset := NewBset(n + 1)
	for i := 0; i < n; i++ {
		if bset.connected(edges[i][0], edges[i][1]) {
			return edges[i]
		}
		bset.union2(edges[i][0], edges[i][1])
	}
	return nil
}
```







# 图搜索

## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230724230315321.png" alt="image-20230724230315321" style="zoom:67%;" />

> dfs:
>
> - 边上的O以及与其相连的都变味@
> - 所有的O都是x
> - 之前的O恢复
>   - 这样可以不使用额外的空间进行

```go
func solve(board [][]byte) {
	m, n := len(board), len(board[0])

	var dfs func(i, j int)
	dfs = func(i, j int) {
		if i < 0 || j < 0 || i >= m || j >= n {
			return
		}
		if board[i][j] != 'O' {
			return
		} else {
			board[i][j] = '#'
			dfs(i-1, j)
			dfs(i, j-1)
			dfs(i+1, j)
			dfs(i, j+1)
		}
	}

	// 从四周进行dfs
	for j := 0; j < n; j++ {
		if board[0][j] == 'O' {
			dfs(0, j)
		}
		if board[m-1][j] == 'O' {
			dfs(m-1, j)
		}
	}
	for i := 1; i < m-1; i++ {
		if board[i][0] == 'O' {
			dfs(i, 0)
		}
		if board[i][n-1] == 'O' {
			dfs(i, n-1)
		}
	}

    // 更改原数组
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if board[i][j] == 'O' {
				board[i][j] = 'X'
			}
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if board[i][j] == '#' {
				board[i][j] = 'O'
			}
		}
	}
}
```

> 并查集, Good
>
> 这里也是用了一个dummy节点
>
> - 四周的, 直接连到dummy
> - 里面的, 向四周相连接

```go
type Bset struct {
	root   []int
	length int
}

func NewBset(length int) *Bset {
	bset := &Bset{length: length}
	bset.root = make([]int, length)
	for i := 0; i < length; i++ {
		bset.root[i] = i
	}
	return bset
}

func (b *Bset) find(x int) int {
	if x != b.root[x] {
		b.root[x] = b.find(b.root[x])
	}
	return b.root[x]
}

func (b *Bset) union2(x, y int) {
	xr, yr := b.find(x), b.find(y)
	if xr == yr {
		return
	}
	b.root[xr] = yr
}

func (b *Bset) connected(x, y int) bool {
	return b.find(x) == b.find(y)
}

func solve(board [][]byte) {
	m, n := len(board), len(board[0])
	bset := NewBset(m*n + 1)

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if board[i][j] == 'O' {
				// 四个角
				if i == 0 || j == 0 || i == m-1 || j == n-1 {
					bset.union2(i*n+j, m*n)
				} else {
					if i > 0 && board[i-1][j] == 'O' {
						bset.union2((i-1)*n+j, i*n+j)
					}
					if j > 0 && board[i][j-1] == 'O' {
						bset.union2(i*n+j-1, i*n+j)
					}
					if i < m-1 && board[i+1][j] == 'O' {
						bset.union2((i+1)*n+j, i*n+j)
					}
					if j < n-1 && board[i][j+1] == 'O' {
						bset.union2(i*n+j+1, i*n+j)
					}
				}
			}
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if !bset.connected(i*n+j, m*n) {
				board[i][j] = 'X'
			}
		}
	}
}
```

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230726163952665.png" alt="image-20230726163952665" style="zoom:67%;" />

> 总感觉这种题目, dfs要比并查集简单

```go
func numIslands(grid [][]byte) int {
	res := 0
	m, n := len(grid), len(grid[0])

	var dfs func(i, j int)
	dfs = func(i, j int) {
		if i < 0 || j < 0 || i >= m || j >= n {
			return
		}
		if grid[i][j] == '1' {
			grid[i][j] = '#'
			dfs(i-1, j)
			dfs(i+1, j)
			dfs(i, j-1)
			dfs(i, j+1)
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == '1' {
				// 在这里记述, 一次遍历一个岛
				res += 1
				dfs(i, j)
			}
		}
	}

	return res
}
```

> 并查集:
>
> - 所有的水, 连载dummy节点
> - 所有的陆地, 与周围相连
> - 求得root一共有点多少个, -1就是结果

```go
func numIslands(grid [][]byte) int {
	m, n := len(grid), len(grid[0])
	bset := NewBset(m*n + 1)
	index := func(i, j int) int {
		return i*n + j
	}
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == '1' {
				if i > 0 && grid[i-1][j] == '1' {
					bset.union2(index(i, j), index(i-1, j))
				}
				if j > 0 && grid[i][j-1] == '1' {
					bset.union2(index(i, j), index(i, j-1))
				}
				if i+1 < m && grid[i+1][j] == '1' {
					bset.union2(index(i, j), index(i+1, j))
				}
				if j+1 < n && grid[i][j+1] == '1' {
					bset.union2(index(i, j), index(i, j+1))
				}
			} else {
				bset.union2(index(i, j), m*n)
			}
		}
	}

	set := make(map[int]int)
	for _, i := range bset.root {
		set[bset.find(i)] = 1
	}
	return len(set) - 1
}
```



## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230802152915582.png" alt="image-20230802152915582" style="zoom:67%;" />

> 典型的拓扑拍戏问题呀
>
> 统计课程安排图中每个节点的入度，生成 入度表 indegrees。
> 借助一个队列 queue，将所有入度为 0 的节点入队。
> 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
> 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。
> 当入度 −1-1−1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
> 在每次 pre 出队时，执行 numCourses--；
> 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。
> 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。
>
> 
>
> 也可以深度优先遍历判断是否有环
>
> 但是dfs其实就和topo排序一样的........., 也是要检查入度

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
	inDegree := make([]int, numCourses)  // 前置节点多少个
	graph := make(map[int][]int)         // 记录图
	queue := []int{}                     // topo队列
	
	for _, pair := range prerequisites { // 填写数据
		inDegree[pair[0]]++
		graph[pair[1]] = append(graph[pair[1]], pair[0])
	}
	for idx, num := range inDegree {
		if num == 0 {
			queue = append(queue, idx)
		}
	}
	visited := 0 // 记录访问的节点数
	for len(queue) != 0 {
		visited += 1
		course := queue[0]
		queue = queue[1:]
		for i := 0; i < len(graph[course]); i++ {
			inDegree[graph[course][i]] -= 1
			if inDegree[graph[course][i]] == 0 {
				queue = append(queue, graph[course][i])
			}
		}
	}
	return visited == numCourses
}
```



## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230802154812969.png" alt="image-20230802154812969" style="zoom:67%;" />

> 还是topo排序呀

```go
func findOrder(numCourses int, prerequisites [][]int) []int {
	inDegree := make([]int, numCourses) // 前置节点多少个
	graph := make(map[int][]int)        // 记录图
	queue := []int{}                    // topo队列
	res := []int{}                      // 记录结果

	for _, pair := range prerequisites { // 填写数据
		inDegree[pair[0]]++
		graph[pair[1]] = append(graph[pair[1]], pair[0])
	}
	for idx, num := range inDegree {
		if num == 0 {
			queue = append(queue, idx)
		}
	}
	for len(queue) != 0 {
		course := queue[0]
		queue = queue[1:]
		res = append(res, course)
		for i := 0; i < len(graph[course]); i++ {
			inDegree[graph[course][i]] -= 1
			if inDegree[graph[course][i]] == 0 {
				queue = append(queue, graph[course][i])
			}
		}
	}
    if len(res) == numCourses {
		return res
	} 
	return nil
}
```



## [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230809132214730.png" alt="image-20230809132214730" style="zoom:67%;" />

> c++的map的key是有序的 => fuck

```go
func findItinerary(tickets [][]string) []string {
	res := []string{"JFK"}
	graph := make(map[string]map[string]int)
	for _, ticket := range tickets {
		if graph[ticket[0]] == nil {
			graph[ticket[0]] = make(map[string]int)
		}
		graph[ticket[0]][ticket[1]] += 1
	}

	var dfs func() bool
	dfs = func() bool {
		if len(res) == len(tickets)+1 {
			return true
		}
		// 保存所有的key, 并排序
		keys := []string{}
		for k, _ := range graph[res[len(res)-1]] {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			if graph[res[len(res)-1]][k] != 0 {
				graph[res[len(res)-1]][k]--
				res = append(res, k)
				if dfs() {
					return true
				}
				res = res[:len(res)-1]
				graph[res[len(res)-1]][k]++
			}
		}
		return false
	}
	dfs()
	return res
}
```



## [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810123603360.png" alt="image-20230810123603360" style="zoom:67%;" />

> dfs直接呗

```go
func findCircleNum(isConnected [][]int) int {
	n := len(isConnected)
	visited := make([]bool, n)
	res := 0

	var dfs func(idx int)
	dfs = func(idx int) {
		for i := 0; i < n; i++ {
			if isConnected[idx][i] == 1 && !visited[i] {
				visited[i] = true
				dfs(i)
			}
		}
	}

	for i := 0; i < n; i++ {
		if !visited[i] {
			res += 1
			visited[i] = true
			dfs(i)
		}
	}
	return res
}
```

## [2328. 网格图中递增路径的数目](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230810162231255.png" alt="image-20230810162231255" style="zoom:67%;" />

> 这道题是把dp的地推放在了dfs里面去了, 哈哈哈
>
> - good
> - 这个dfs 对于一个点的计算, 只会进行一次



## [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

<img src="./%E5%9B%9E%E6%BA%AF-%E6%90%9C%E7%B4%A2.assets/image-20230829224718520.png" alt="image-20230829224718520" style="zoom:67%;" />

> 感觉写得反而有些复杂, 直接全设置为0不就ok了吗

```c++
class Solution {
public:
	void dfs(vector<vector<int>>& grid, int i, int j){
		if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())	return;
		if(grid[i][j]==1){
			grid[i][j] = 2;
			dfs(grid, i+1, j);
			dfs(grid, i-1, j);
			dfs(grid, i, j+1);
			dfs(grid, i, j-1);
		}			
	}
	
	
    int numEnclaves(vector<vector<int>>& grid) {
		for(int i=0; i<grid.size(); i++){
			dfs(grid, i, 0);
			dfs(grid, i, grid[0].size()-1);
		}
		for(int j=0; j<grid[0].size(); j++){
			dfs(grid, 0, j);
			dfs(grid, grid.size()-1, j);
		}
		
		
		int res {};
		for(int i=0; i<grid.size(); i++){
			for(int j=0; j<grid[0].size(); j++){
				if(grid[i][j]==1)
					res ++;
			}
		}
		return res;
    }
};
```















































