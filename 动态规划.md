## [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230716131138863.png" alt="image-20230716131138863" style="zoom:67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230716131936844.png" alt="image-20230716131936844" style="zoom: 67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230716131901516.png" alt="image-20230716131901516" style="zoom: 67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230716132054652.png" alt="image-20230716132054652" style="zoom:67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230716132120462.png" alt="image-20230716132120462" style="zoom:67%;" />

$f[i][j]=\left\{\begin{array}{ll}
\text { if }\left(p[j] \neq{ ^ *},\right)=\left\{\begin{array}{ll}
f[i-1][j-1], & \text { matches }(s[i], p[j]) \\
\text { false, } & \text { otherwise }
\end{array}\right. \\
\text { otherwise }=\left\{\begin{array}{ll}
f[i-1][j] \text { or } f[i][j-2], & \text { matches }(s[i], p[j-1]) \\
f[i][j-2], & \text { otherwise }
\end{array}\right.
\end{array}\right.$

对于*的dp是递归的哦, 向里面继续找, 相当于从最底层一直向上

```go
func isMatch(s string, p string) bool {
	match := func(i, j int) bool {
		if i == 0 {
			return false
		}
		if p[j-1] == '.' {
			return true
		}
		return s[i-1] == p[j-1]
	}

	lenS, lenP := len(s), len(p)
	dp := make([][]bool, lenS+1)
	for i := 0; i < len(dp); i++ {
		dp[i] = make([]bool, lenP+1)
	}

	dp[0][0] = true
	for i := 0; i <= lenS; i++ {
		for j := 1; j <= lenP; j++ {
			if p[j-1] == '*' {
				dp[i][j] = dp[i][j] || dp[i][j-2]
				if match(i, j-1) {
					dp[i][j] = dp[i][j] || dp[i-1][j]
				}
			} else if match(i, j) {
				dp[i][j] = dp[i-1][j-1]
			}
		}
	}
	return dp[lenS][lenP]
}
```

## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230718112243468.png" alt="image-20230718112243468" style="zoom:67%;" />

> 两种解题思路 
>
> - 栈
>   - 栈中有孤立右括号, 重新计数
> - DP
>   - s 前面加一个占位符, 免去很多边界条件的判断!!!!!!

我们定义 $dp[i]$ 表示以下标 i 字符结尾的最长有效括号的长度。我们将 $\textit{dp}$ 数组全部初始化为 0 。显然有效的子串一定以 $\text{‘)’}$ 结尾，因此我们可以知道以‘(’’ 结尾的子串对应的 dp 值必定为 0 ，我们只需要求解 ‘)’ 在 dp 数组中对应位置的值。

我们从前往后遍历字符串求解 dp 值，我们每两个字符检查一次：

s[i]=‘)’ 且 s[i-1]=‘(’，也就是字符串形如 “……()”，我们可以推出：

$\textit{dp}[i]=\textit{dp}[i-2]+2$

我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。

s[i]=‘)’ 且 s[i−1]=‘)’，也就是字符串形如“……))”，我们可以推出：
如果 $s[i−dp[i−1]−1]=($，那么
$dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2$

```go
func longestValidParentheses(s string) int {
	if len(s) <= 1 {
		return 0
	}
	// 免去边界条件判断
	s = "#" + s
	dp := make([]int, len(s))
	res := math.MinInt32

	for idx := 1; idx < len(s); idx++ {
		c := s[idx]
		if c == ')' {
			if s[idx-1] == '(' {
				dp[idx] = dp[idx-2] + 2
			} else if s[idx-1] == ')' {
				if s[idx-dp[idx-1]-1] == '(' {
					dp[idx] = dp[idx-1] + dp[idx-dp[idx-1]-2] + 2
				}
			}
		}
		if dp[idx] > res {
			res = dp[idx]
		}
	}
	return res
}
```

具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

**栈顶元素 => 最后一个还没有匹配到的下标**

对于遇到的每个 '(’ ，我们将它的下标放入栈中
对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：**当前的最大长度可以延伸到新的栈顶**
如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。

```go
func longestValidParentheses(s string) int {
	maxAns := 0
	stack := []int{}
	stack = append(stack, -1)
	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			stack = append(stack, i)
		} else {
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				stack = append(stack, i)
			} else {
				maxAns = max(maxAns, i-stack[len(stack)-1])
			}
		}
	}
	return maxAns
}
```

## [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230718203349856.png" alt="image-20230718203349856" style="zoom:67%;" />

> 与10题真的很相似啊
>
> 考虑空字符串, 所以开空间必须长度+1
>
> - 这道题的匹配条件比迪10题好一点
> - 注意两个为0的边界条件
> - 单纯的*, 不用于前面的字符结合, 所以转移方程好写一点

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230718205902151.png" alt="image-20230718205902151" style="zoom: 67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230718210220156.png" alt="image-20230718210220156" style="zoom:67%;" />

```go
func isMatch(s string, p string) bool {
	lenS, lenP := len(s), len(p)
	dp := make([][]bool, lenS+1)
	for i := 0; i < len(dp); i++ {
		dp[i] = make([]bool, lenP+1)
	}
	dp[0][0] = true
	// dp[i][j] 为true
	for j := 0; j < len(p); j++ {
		if p[j] != '*' {
			break
		} else {
			dp[0][j+1] = true
		}
	}
	for i := 1; i <= lenS; i++ {
		for j := 1; j <= lenP; j++ {
			if p[j-1] == '*' {
				// 不使用这个* // 只匹配一个, 会递归算出多个
				dp[i][j] = dp[i][j] || dp[i][j-1] || dp[i-1][j]
			} else if s[i-1] == p[j-1] || p[j-1] == '?' {
				dp[i][j] = dp[i-1][j-1]
			}
		}
	}
	return dp[lenS][lenP]
}
```

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230719100716596.png" alt="image-20230719100716596" style="zoom:67%;" />

> 动态规划!
>
> $dp[i] = max(dp[i-1]+nums[i], nums[i])$
>
> $dp[0] = nums[0]$

```go
func maxSubArray(nums []int) int {
	dp := make([]int, len(nums), len(nums))
	dp[0] = nums[0]
	res := nums[0]
	for i := 1; i < len(nums); i++ {
		if nums[i] > dp[i-1]+nums[i] {
			dp[i] = nums[i]
		} else {
			dp[i] = dp[i-1] + nums[i]
		}
		if dp[i] > res {
			res = dp[i]
		}
	}
	return res
}
```

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230719155315255.png" alt="image-20230719155315255" style="zoom:67%;" />

> 每个人的dp第一题

```go
func climbStairs(n int) int {
	dp := make([]int, n+1, n+1)
	dp[0] = 1
	dp[1] = 1
	for i := 2; i < n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230719170517644.png" alt="image-20230719170517644" style="zoom:67%;" />

> $\left\{\begin{matrix} 
>   dp[0][0] = 1 \\  
>   dp[i][j] = dp[i-1][j] + dp[i][j-1]
> \end{matrix}\right. $
>
> 
>
> 状态压缩一下, 还是很easy的

```go
func uniquePaths(m int, n int) int {
	dp := make([]int, n, n)
	for i := 0; i < n; i++ {
		dp[i] = 1
	}

	// 压缩dp
	for i := 1; i < m; i++ {
		dp[0] = dp[0]
		for j := 1; j < n; j++ {
			dp[j] = dp[j]+dp[j-1]
		}
	}
	return dp[n-1]
}
```

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230719172401672.png" alt="image-20230719172401672" style="zoom:67%;" />

> 判断一下就ok了
>
> 真有傻叉把石头放在哦出口啊

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	m, n := len(obstacleGrid), len(obstacleGrid[0])
	dp := make([]int, n, n)

	// sha cha
	if obstacleGrid[0][0] == 1 {
		return 0
	}

	dp[0] = 1
	for i := 1; i < n; i++ {
		if obstacleGrid[0][i] == 1 {
			dp[i] = 0
		} else {
			dp[i] = dp[i-1]
		}
	}

	for i := 1; i < m; i++ {
		if obstacleGrid[i][0] == 1 {
			dp[0] = 0
		} else {
			dp[0] = dp[0]
		}
		for j := 1; j < n; j++ {
			if obstacleGrid[i][j] == 1 {
				dp[j] = 0
			} else {
				dp[j] += dp[j-1]
			}
		}
	}
	return dp[n-1]
}
```

## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230719221048591.png" alt="image-20230719221048591" style="zoom:67%;" />

> - 真的是简单的dp
> - 使用状态压缩, 一位数组 Good

```go
func minPathSum(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	dp := make([]int, n, n)
	dp[0] = grid[0][0]
	for i := 1; i < n; i++ {
		dp[i] = dp[i-1] + grid[0][i]
	}

	for i := 1; i < m; i++ {
		dp[0] = grid[i][0] + dp[0]
		for j := 1; j < n; j++ {
			dp[j] = min(dp[j-1], dp[j]) + grid[i][j]
		}
	}
	return dp[n-1]
}
```



## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230722144909528.png" alt="image-20230722144909528" style="zoom:67%;" />

> 动态规划 66666
>
> 
>
> 按照树根来计算的
>
> - 看左边和右边各有多少个数字
> - 相乘加入结果就ok啦

```go
func numTrees(n int) int {
	if n == 0 || n == 1 {
		return 1
	}
	dp := make([]int, n+1, n+1)
	dp[0] = 1
	dp[1] = 1
	dp[2] = 2

	for i := 3; i <= n; i++ {
		for j := 0; j < i; j++ {
            // 左右各有多少种
			dp[i] += dp[j] * dp[i-j-1]
		}
	}
	return dp[n]
}
```

## [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230722231701478.png" alt="image-20230722231701478" style="zoom:67%;" />

> 长度200, 回溯肯定是不行的啊
>
> 字符串的题 dfs 简直就是弟弟中的弟弟。 遇到字符串题，先想DP....
>
> 
>
> 这个怎么dp来做呢??
>
> 得先找到数组代表什么, 之后再找到转移方程
>
> - 长度不等 直接false
> - dp\[i][j] s1的前i s2的前j 能否组成s3的i+j
> - **使用滚动数组优化空间复杂度**

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230722232652376.png" alt="image-20230722232652376" style="zoom: 67%;" />

```go
// good
func isInterleave(s1 string, s2 string, s3 string) bool {
	l1, l2, l3 := len(s1), len(s2), len(s3)
	if l1+l2 != l3 {
		return false
	}

	// 创建数组
	dp := make([][]bool, l1+1, l1+1)
	for i := 0; i <= l1; i++ {
		dp[i] = make([]bool, l2+1, l2+1)
	}

	dp[0][0] = true
	for i := 0; i <= l1; i++ {
		for j := 0; j <= l2; j++ {
			if i > 0 {
				dp[i][j] = dp[i][j] || (dp[i-1][j] && s1[i-1] == s3[i+j-1])
			}
			if j > 0 {
				dp[i][j] = dp[i][j] || (dp[i][j-1] && s2[j-1] == s3[i+j-1])
			}
		}
	}
	return dp[l1][l2]
}
```

```go
// 压缩 Good
func isInterleave(s1 string, s2 string, s3 string) bool {
	l1, l2, l3 := len(s1), len(s2), len(s3)
	if l1+l2 != l3 {
		return false
	}

	// 创建数组
	dp := make([]bool, l2+1, l2+1)
	dp[0] = true

	// dp
	for i := 0; i <= l1; i++ {
		for j := 0; j <= l2; j++ {
			if i > 0 {
				dp[j] = dp[j] && s1[i-1] == s3[i+j-1]
			}
			if j > 0 {
				dp[j] = dp[j] || (dp[j-1] && s2[j-1] == s3[i+j-1])
			}
		}
		fmt.Println(dp)
	}
	return dp[l2]
}
```

## [87. 扰乱字符串](https://leetcode.cn/problems/scramble-string/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230723004355697.png" alt="image-20230723004355697" style="zoom:67%;" />

> 字符串 => 必须直接想到dp!!!!!!!!!!!!

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230723012525205.png" alt="image-20230723012525205" style="zoom:50%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230723012537354.png" alt="image-20230723012537354" style="zoom:50%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230723012609008.png" alt="image-20230723012609008" style="zoom:50%;" />

```go
func isScramble(s1 string, s2 string) bool {
	l1, l2 := len(s1), len(s2)
	if l1 != l2 {
		return false
	}

	// go开三维数组真麻烦
	dp := make([][][]bool, l1, l1)
	for i := 0; i < l1; i++ {
		dp[i] = make([][]bool, l2, l2)
		for j := 0; j < l1; j++ {
			dp[i][j] = make([]bool, l1+1, l1+1)
		}
	}
	// 初始化单个字符的情况
	for i := 0; i < l1; i++ {
		for j := 0; j < l1; j++ {
			dp[i][j][1] = s1[i] == s2[j]
		}
	}

	// 区间长度2-n
	for l := 2; l <= l1; l++ {
		// s1 s2的起点位置
		for i := 0; i <= l1-l; i++ {
			for j := 0; j <= l1-l; j++ {
				// 枚举划分情况
				for k := 1; k <= l-1; k++ {
					//s1t1
					if dp[i][j][k] && dp[i+k][j+k][l-k] {
						dp[i][j][l] = true
						break
					}
					// s1 t2
					if dp[i][j+l-k][k] && dp[i+k][j][l-k] {
						dp[i][j][l] = true
						break
					}
				}
			}
		}
	}
	return dp[0][0][l1]
}
```





## [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230724113258129.png" alt="image-20230724113258129" style="zoom:67%;" />

> gogogo
>
> 一个b三角形dp还写的这么蹩脚

```go
func minimumTotal(triangle [][]int) int {
	dp := make([]int, 201, 201)
	dp[0] = triangle[0][0]
	for i := 1; i < len(triangle); i++ {
		t1 := dp[0]
		dp[0] += triangle[i][0]
		for j := 1; j < i; j++ {
			t2 := dp[j]
			dp[j] = min(dp[j], t1) + triangle[i][j]
			t1 = t2
		}
		dp[i] = triangle[i][i] + t1
		fmt.Println(dp)
	}
	res := math.MaxInt
	for i := 0; i < len(triangle); i++ {
		res = min(res, dp[i])
	}
	return res
}
```

## [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230725224327320.png" alt="image-20230725224327320" style="zoom:67%;" />

> 这种题目一眼看上去就肯定是dp啦
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230728021115821.png" alt="image-20230728021115821" style="zoom:67%;" />
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230728021308794.png" alt="image-20230728021308794" style="zoom:67%;" />

> 这个回文串的判断还挺牛逼
>
> - 我当时自己想的是dp[i]代表以I为结尾需要分割多少次, 后面的没想到

```go
func minCut(s string) int {
	n := len(s)
	chars := []byte(s)

	// 构建回文串数组
	g := make([][]bool, n+1)
	for r := 0; r <= n; r++ {
		g[r] = make([]bool, n+1)
	}

	// 枚举所有的回文串
	for r := 1; r <= n; r++ {
		for l := r; l >= 1; l-- {
			if l == r {
				g[l][r] = true
			} else {
				if chars[l-1] == chars[r-1] {
					if r-l == 1 || g[l+1][r-1] {
						g[l][r] = true
					}
				}
			}
		}
	}
	
	dp := make([]int, n+1)
	for r := 1; r <= n; r++ {
		if g[1][r] { // 不需要分割
			dp[r] = 0
		} else {
			// 先设定一个最大分割次数（r 个字符最多消耗 r - 1 次分割）
			dp[r] = r - 1
			for l := 1; l <= r; l++ {
				if g[l][r] {
					dp[r] = min(dp[r], dp[l-1]+1)
				}
			}
		}
	}
	return dp[n]
}
```



## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230726165433540.png" alt="image-20230726165433540" style="zoom:67%;" />

> 如何dp呢???????????
>
> 怎么处理负数呢?????????????
>
> 
>
> 标签：动态规划
> 遍历数组时计算当前最大值，不断更新
> 令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])
> 由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])
> 当负数出现时则imax与imin进行交换再进行下一步计算
> 时间复杂度：O(n)
>
> 
>
> 有可能最小的数字, 摇身一变变成最大数

> 无后效性
>
> 用 0 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最小值；
> 用 1 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最大值。
>
> 牢记状态的定义，一定以下标 `i` 结尾，即：**乘积数组中 `nums[i]` 必须被选取**。
>
> 不依赖于后面的数字
>
> 有正数, 有负数, 那就即记录最大, 又记录最小
>
> - `dp[i][1]` 表示：以 `nums[i]` 结尾的连续子序列的乘积的最大值；
> - `dp[i][0]` 表示：以 `nums[i]` 结尾的连续子序列的乘积的最小值。

```go
func maxProduct(nums []int) int {
	n := len(nums)
	res := nums[0]

	// (n,2) 的数组, 来记录每个的最大值和最小值
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, 2)
	}

	// 初始化
	dp[0][0] = nums[0]
	dp[0][1] = nums[0]

	for i := 1; i < n; i++ {
		// 是正数
		if nums[i] >= 0 {
			dp[i][1] = max(nums[i], nums[i]*dp[i-1][1])
			dp[i][0] = min(nums[i], nums[i]*dp[i-1][0])
		} else {
			dp[i][1] = max(nums[i], nums[i]*dp[i-1][0])
			dp[i][0] = min(nums[i], nums[i]*dp[i-1][1])
		}
		res = max(res, dp[i][1])
	}
	return res
}
```



## [174. 地下城游戏](https://leetcode.cn/problems/dungeon-game/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230727232014928.png" alt="image-20230727232014928" style="zoom:67%;" />

> 我第一眼想到的是回溯啊, dfs, 应该可以吧
>
> No 因为中间是有补充的, dfs只能记录这个路径的加和
>
> 这种题目, 又有正又有负, 应该是dp啦

> 如果按照从左上往右下的顺序进行动态规划，对于每一条路径，我们需要同时记录两个值。第一个是「从出发点到当前点的路径和」，第二个是「从出发点到当前点所需的最小初始值」。而这两个值的重要程度相同
>
> 我们希望「从出发点到当前点的路径和」尽可能大，而「从出发点到当前点所需的最小初始值」尽可能小。这两条路径各有优劣。
>
> 因此，如果按照从左上往右下的顺序进行动态规划，我们无法直接确定到达(1,2) 的方案，因为有两个重要程度相同的参数同时影响后续的决策。也就是说，这样的动态规划是不满足「无后效性」的。
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230727233448423.png" alt="image-20230727233448423" style="zoom:67%;" />
>
> 
>
> 因为路径里面有正数, 所以路径和和所需的最小值无法统一的

```go
func calculateMinimumHP(dungeon [][]int) int {
	n, m := len(dungeon), len(dungeon[0])
	dp := make([][]int, n+1)
	for i := 0; i < len(dp); i++ {
		dp[i] = make([]int, m+1)
		for j := 0; j < len(dp[i]); j++ {
			dp[i][j] = math.MaxInt32 // 全部设置最大, min直接被忽略
		}
	}
	dp[n][m-1], dp[n-1][m] = 1, 1
	for i := n - 1; i >= 0; i-- {
		for j := m - 1; j >= 0; j-- {
			dp[i][j] = max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1)
		}
	}
	return dp[0][0]
}
```

## [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230804104158512.png" alt="image-20230804104158512" style="zoom:67%;" />

> 第一反应: 这不是最大矩形, 单调站吗
>
> - 是完全可以的

```go
func maximalSquare(matrix [][]byte) int {
	res := 0
	// 方便处理边界, 保证所有数字都可以弹出计算 多一个元素 最后一个是0
	height := make([]int, len(matrix[0])+1)

	for i := 0; i < len(matrix); i++ {
		// 相加
		for j := 0; j < len(matrix[0]); j++ {
			// 高度要是一致连续的
			if matrix[i][j] != '0' {
				height[j] += int(matrix[i][j] - '0')
			} else {
				height[j] = 0
			}
		}

		// 单调栈
		stack := make([]int, 0)
		for j := 0; j < len(height); j++ {
			for len(stack) != 0 && height[stack[len(stack)-1]] > height[j] {
				// 要弹出的栈顶元素
				curr_height := height[stack[len(stack)-1]]

				// 右边界
				// curr_height在遍历到第i个的时候被弹出, 代表直到i-1都是比它大的
				right_border := j - 1

				// 弹出元素
				stack = stack[:len(stack)-1]

				//左边界, 如果stack没有元素, 代表一直向左都比这个大, 左边界可延伸
				left_border := 0
				if len(stack) != 0 {
					left_border = stack[len(stack)-1] + 1
				}

				// 正方形啊
				if t := min(curr_height, right_border-left_border+1) * min(curr_height, right_border-left_border+1); t > res {
					res = t
				}
			}
			stack = append(stack, j)
		}
	}
	return res
}
```

> 动态规划 DP
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230804111805214.png" alt="image-20230804111805214" style="zoom:33%;" />

```go
func maximalSquare(matrix [][]byte) int {
	res := 0
	m, n := len(matrix), len(matrix[0])
	dp := make([][]int, m)
	
	for i := 0; i < m; i++ {
		dp[i] = make([]int, n)
		if matrix[i][0] == '1' {
			dp[i][0] = 1
			res = 1
		}
	}

	for j := 0; j < n; j++ {
		if matrix[0][j] == '1' {
			dp[0][j] = 1
			res = 1
		}
	}

	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			if matrix[i][j] == '1' {
                // 中心
				dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1
				res = max(res, dp[i][j]*dp[i][j])
			}
		}
	}
	return res
}
```

## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808151210425.png" alt="image-20230808151210425" style="zoom:67%;" />

> - 注意下面的(i-j)*j 不要忽略啊
> - 考虑dp[3], 最大是1\*2, 而不是1\*dp[2]

```go
func integerBreak(n int) int {
	dp := make([]int, n+1)
	dp[2] = 1
	for i := 3; i <= n; i++ {
		for j := 2; j < i; j++ {
			dp[i] = max(dp[i], max((i-j)*dp[j], (i-j)*j))
		}
	}
	return dp[n]
}
```

> 数学
>
> - 全部分成3
> - 如果剩下一个4, 那么这个4保留

```go
func integerBreak(n int) int {
    if n <= 3 {
        return n - 1
    }
    quotient := n / 3
    remainder := n % 3
    if remainder == 0 {
        return int(math.Pow(3, float64(quotient)))
    } else if remainder == 1 {
        return int(math.Pow(3, float64(quotient - 1))) * 4
    }
    return int(math.Pow(3, float64(quotient))) * 2
}
```

> 直接优化的dp

```go
func integerBreak(n int) int {
    if n <= 3 {
        return n - 1
    }
    dp := make([]int, n + 1)
    dp[2] = 1
    for i := 3; i <= n; i++ {
        dp[i] = max(max(2 * (i - 2), 2 * dp[i - 2]), max(3 * (i - 3), 3 * dp[i - 3]))
    }
    return dp[n]
}
```



## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809003554930.png" alt="image-20230809003554930" style="zoom:67%;" />

> 判断回文都是双向判断的哈
>
> dp\[i][j] s再i-j内的结果
>
> 那么就是就j > i

```go
func longestPalindromeSubseq(s string) int {
	length := len(s)
	// 回文的都是初始化为二维的
	dp := make([][]int, length)
	for i := 0; i < length; i++ {
		dp[i] = make([]int, length)
		dp[i][i] = 1
	}
	for i := length - 1; i >= 0; i-- {
		for j := i + 1; j < length; j++ {
			if s[i] == s[j] {
				// 所以i从大到小, j从小到大
				dp[i][j] = dp[i+1][j-1] + 2
			} else {
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
			}
		}
	}
	return dp[0][length-1]
}
```



## [940. 不同的子序列 II](https://leetcode.cn/problems/distinct-subsequences-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809165739349.png" alt="image-20230809165739349" style="zoom:67%;" />

> 这么大, 肯定是dp
>
> 字符串一般是按照结尾来进行的
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809171056717.png" alt="image-20230809171056717" style="zoom:67%;" />
>
> 
>
> - 这样的子序列, 有时需要增加一个空串来占位会更简单

```go
func distinctSubseqII(s string) int {
	dp := make([]int, len(s))
	cnt := make([]int, 26)
	const MOD = int(1e9 + 7)

	dp[0] = 2
	cnt[s[0]-'a'] = 1 // 第一个字母, 增加了一个
	for i := 1; i < len(s); i++ {
		dp[i] = (dp[i-1]*2 - cnt[s[i]-'a']) % MOD
		cnt[s[i]-'a'] = dp[i-1]
	}
	return (dp[len(s)-1] - 1 + MOD) % MOD
}
```













## [956. 最高的广告牌](https://leetcode.cn/problems/tallest-billboard/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809155249975.png" alt="image-20230809155249975" style="zoom:67%;" />

> 每一根钢筋有三种使用
>
> - *1
> - *-1
> - *0
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809160319050.png" alt="image-20230809160319050" style="zoom:67%;" />
>
> MAP记录的是这些组合里面取正的的高度
>
> - 这道题是使用map来进行dp, good

```go
func tallestBillboard(rods []int) int {
	dp := map[int]int{0: 0}
	for _, rod := range rods {
		tmpMap := map[int]int{}
		for k, v := range dp {
			tmpMap[k] = v
		}
		for k, v := range tmpMap {
			// *1
			dp[k+rod] = max(v+rod, dp[k+rod])
			// *-1
			dp[k-rod] = max(dp[k-rod], v)
		}
	}
	return dp[0]
}
```



## [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230831170229223.png" alt="image-20230831170229223" style="zoom:67%;" />

> **![image-20230831170327389](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230831170327389.png)**
>
> 统一注释，total为数组的总和，maxSum为最大子数组和，minSum为最小子数组和，curMax为包含当前元素的最大子数组和，curMin为包含当前元素的最小子数组和
>
> 应该可以看作是一种dp

```go
func maxSubarraySumCircular(nums []int) int {
	total, maxSum, minSum, currMax, currMin := nums[0], nums[0], nums[0], nums[0], nums[0]

	for i := 1; i < len(nums); i++ {
		total += nums[i]
		currMax = max(currMax+nums[i], nums[i])
		maxSum = max(maxSum, currMax)
		currMin = min(currMin+nums[i], nums[i])
		minSum = min(minSum, currMin)
	}

	//等价于if maxSum < 0
	if total == minSum {
		return maxSum
	} else {
		return max(maxSum, total-minSum)
	}
}
```







# 字符串上的DP

## [828/83. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20231128143528032.png" alt="image-20231128143528032" style="zoom:67%;" />

> - 这道题给了一个新思路 => 计算每一个元素在结果中的贡献

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20231128171147625.png" alt="image-20231128171147625" style="zoom: 67%;" />

```go
func uniqueLetterString(s string) int {
	idx := make(map[rune][]int)
	for i, c := range s {
		idx[c] = append(idx[c], i)
	}

	res := 0
	for _, arr := range idx {
		arr = append(append([]int{-1}, arr...), len(s))
		for i := 1; i < len(arr)-1; i++ {
			res += (arr[i] - arr[i-1]) * (arr[i+1] - arr[i])
		}
	}
	return res
}
```

> - 使用线性DP的方法







# 编辑距离

## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809002050215.png" alt="image-20230809002050215" style="zoom:67%;" />

> 完全可以双指针来进行
>
> 但是在这里要使用dp

```go
func isSubsequence(text1 string, text2 string) bool {
	l1, l2 := len(text1), len(text2)
	dp := make([]int, l2+1)
	for i := 1; i <= l1; i++ {
		t1 := dp[0]
		for j := 1; j <= l2; j++ {
			t2 := dp[j]
			if text2[j-1] == text1[i-1] {
				dp[j] = t1 + 1
			} else {
				dp[j] = max(dp[j], dp[j-1])
			}
			t1 = t2
		}
	}
	return dp[l2] == len(text1)
}
```



## [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230724150106736.png" alt="image-20230724150106736" style="zoom:67%;" />

> 之前自己做出来过, 得好好想一想
>
> - 这一类问题，基本是要分析两种情况 s[i - 1] 与 t[j - 1]相等
>
> - s[i - 1] 与 t[j - 1] 不相等
>
> - 当s[i - 1] 与 t[j - 1]相等时，dp\[i][j]可以有两部分组成。
>
>   - 一部分是用s[i - 1]来匹配，那么个数为dp\[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp\[i-1][j-1]。
>
>   - 一部分是不用s[i - 1]来匹配，个数为dp\[i - 1][j]。
>
>   - 所以当s[i - 1] 与 t[j - 1]相等时，dp\[i][j] = dp\[i - 1][j - 1] + dp\[i - 1][j];
>
>     当s[i - 1] 与 t[j - 1]不相等时，dp\[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp\[i - 1][j]
>
> - 初始条件
>
>   - dp\[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。
>
>   - 那么dp\[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。
>
>     再来看dp\[0][j]，dp\[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。
>
>     那么dp\[0][j]一定都是0，s如论如何也变成不了t。
>
>     最后就要看一个特殊位置了，即：dp\[0][0] 应该是多少。
>
>     dp\[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。

```go
// 一维压缩dp
// 两个循环里面各一个tmp
func numDistinct(s string, t string) int {
	ls, lt := len(s), len(t)
	// 一维的
	dp := make([]int, lt+1, lt+1)
	dp[0] = 1

	for i := 1; i <= ls; i++ {
		t1 := dp[0]
		for j := 1; j <= lt; j++ {
			t2 := dp[j]
			if s[i-1] == t[j-1] {
				dp[j] = dp[j] + t1
			}
			t1 = t2
		}
	}
	return dp[lt]
}
```



## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808234133450.png" alt="image-20230808234133450" style="zoom:67%;" />

> 为了避免边界条件判断, dp中的0 是占位的
>
> - 是子数组, 不是子序列, 要连续

```go
func findLength(nums1 []int, nums2 []int) int {
	l1, l2, res := len(nums1), len(nums2), 0
	dp := make([]int, l2+1)
	for i := 1; i <= l1; i++ {
		t1 := dp[0]
		for j := 1; j <= l2; j++ {
			t2 := dp[j]
			if nums2[j-1] == nums1[i-1] {
				dp[j] = t1 + 1
				res = max(res, dp[j])
			} else {
				dp[j] = 0
			}
			t1 = t2
		}
	}
	return res
}
```

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) LCS

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808235252600.png" alt="image-20230808235252600" style="zoom: 67%;" />

> 和上面的比较
>
> - 子序列和子数组的区别

```go
func longestCommonSubsequence(text1 string, text2 string) int {
	l1, l2 := len(text1), len(text2)
	dp := make([]int, l2+1)
	for i := 1; i <= l1; i++ {
		t1 := dp[0]
		for j := 1; j <= l2; j++ {
			t2 := dp[j]
			if text2[j-1] == text1[i-1] {
				dp[j] = t1 + 1
			} else {
				dp[j] = max(dp[j], dp[j-1])
			}
			t1 = t2
		}
	}
	return dp[l2]
}
```



## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) LIS

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809104312340.png" alt="image-20230809104312340" style="zoom:67%;" />

> 维护并更新
>
> - 贪心法, 存的是当前长度里面选择的数字最小的
> - 当然要使用二分法

```go
// dp
func lengthOfLIS(nums []int) int {
	dp := make([]int, len(nums)+1)
	dp[0] = 1
	res := 1
	for i := 1; i < len(nums); i++ {
		maxVal := 0
		for j := 0; j < i; j++ {
			if nums[j] < nums[i] {
				if maxVal < dp[j] {
					maxVal = dp[j]
				}
			}
		}
		dp[i] = maxVal + 1
		if dp[i] > res {
			res = dp[i]
		}
	}
	return res
}
```

```go
func bisect(val int, seq []int) int {
	low, high := 0, len(seq)-1
	for low < high {
		mid := low + (high-low)/2
		if seq[mid] < val {
			low = mid + 1
		} else {
			high = mid
		}
	}
	return low
}

func lengthOfLIS(nums []int) int {
	dp := []int{}
	dp = append(dp, -10000)
	for i := 0; i < len(nums); i++ {
		if nums[i] > dp[len(dp)-1] {
			dp = append(dp, nums[i])
		} else {
            // 之后再小的都可以往后排
			dp[bisect(nums[i], dp)] = nums[i]
		}
	}
	return len(dp) - 1
}
```













## P1439 【模板】最长公共子序列

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809104203807.png" alt="image-20230809104203807" style="zoom:67%;" />

> 直接使用lcs, o(n2)会超时
>
> - 注意这是一个1-n的排列
> - 可以用哈希, 来做一个LIS

```go
func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var n int
	fmt.Fscan(in, &n)
	dp := []int{}
	s1 := make([]int, n+1, n+1)
	s2 := make([]int, n+1, n+1)
	h := make([]int, n+1, n+1)

	for i := 1; i <= n; i++ {
		fmt.Fscan(in, &s1[i])
		h[s1[i]] = i
	}
	for i := 1; i <= n; i++ {
		fmt.Fscan(in, &s2[i])
	}
	dp = append(dp, 0)
	for i := 1; i <= n; i++ {
		if h[s2[i]] > h[dp[len(dp)-1]] {
			dp = append(dp, s2[i])
		} else {
			dp[bisect(s2[i], dp, h)] = s2[i]
		}
	}
	fmt.Println(len(dp) - 1)
}

func bisect(val int, seq []int, h []int) int {
	low, high := 0, len(seq)-1
	for low < high {
		mid := low + (high-low)/2
		if h[seq[mid]] < h[val] {
			low = mid + 1
		} else {
			high = mid
		}
	}
	return low
}
```

































## [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809001709941.png" alt="image-20230809001709941" style="zoom:67%;" />

> 和上面完全一样

```go
func maxUncrossedLines(nums1 []int, nums2 []int) int {
	l1, l2 := len(nums1), len(nums2)
	dp := make([]int, l2+1)
	for i := 1; i <= l1; i++ {
		t1 := dp[0]
		for j := 1; j <= l2; j++ {
			t2 := dp[j]
			if nums2[j-1] == nums1[i-1] {
				dp[j] = t1 + 1
			} else {
				dp[j] = max(dp[j], dp[j-1])
			}
			t1 = t2
		}
	}
	return dp[l2]
}
```



## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230721100401431.png" alt="image-20230721100401431" style="zoom:67%;" />

> 经典的DP问题啊啊啊啊啊啊 fkfkfkfkfk
>
> 
>
> 在获取\[i]\[j]的时候, 前面的已经匹配完了, 不要再去想他们是怎么匹配到得了
>
> - 如果(i) 与(j) 相等 直接继承i-1, j-1
> - 如果不相等 1+min
>   - 替换 i-1 j-1
>   - 删除 i j-1
>   - 插入 i-1 j

```go
func minDistance(word1 string, word2 string) int {
	l1, l2 := len(word1), len(word2)
	dp := make([][]int, l1+1, l1+1)
	for i := 0; i < l1+1; i++ {
		dp[i] = make([]int, l2+1, l2+1)
	}

	// 初始化, 这些智能逐个增加字符决定
	for i := 0; i < l2+1; i++ {
		dp[0][i] = i
	}

	for i := 0; i < l1+1; i++ {
		dp[i][0] = i
	}
	
    // 遍历dp
	for i := 1; i < l1+1; i++ {
		for j := 1; j < l2+1; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]))
			}
		}
	}
	return dp[l1][l2]
}
```

```go
func minDistance(word1 string, word2 string) int {
	l1, l2 := len(word1), len(word2)
	dp := make([]int, l2+1, l2+1)

	// 初始化, 这些智能逐个增加字符决定
	for i := 0; i < l2+1; i++ {
		dp[i] = i
	}

	// 压缩dp
	for i := 1; i < l1+1; i++ {
		// 一个缓存在第一层循环, 另一个在里层更新
		t1, t2 := dp[0], 0
		dp[0] = i
		for j := 1; j < l2+1; j++ {
			t2 = dp[j]
			if word1[i-1] == word2[j-1] {
				dp[j] = t1
			} else {
				dp[j] = 1 + min(t1, min(t2, dp[j-1]))
			}
			t1 = t2
		}
	}
	return dp[l2]
}
```

# 01背包dp

## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230725130253369.png" alt="image-20230725130253369" style="zoom:67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230725130421578.png" alt="image-20230725130421578" style="zoom:67%;" />

> 看着长度就知道回溯肯定是必行了
>
> 而且不要求具体方案, 所以肯定是dp
>
> 
>
> 相当于背包问题哈

```go
func wordBreak(s string, wordDict []string) bool {
	// 背包大小
	bag := len(s)
	dp := make([]bool, bag+1)
	// 不装的话,肯定是这一种方案
	dp[0] = true
	// 放的是低多少个背包容量
	for j := 0; j <= bag; j++ {
		// 对于每个词进行遍历
		for i := 0; i < len(wordDict); i++ {
			// 词比当前容量都大, 继续
			if j < len(wordDict[i]) {
				continue
			}
			// 当前容量正好够放入这个词
			if s[j-len(wordDict[i]):j-len(wordDict[i])+len(wordDict[i])] == wordDict[i] {
				// 看之前装没装
				dp[j] = dp[j] || dp[j-len(wordDict[i])]
			}
		}
	}
	return dp[bag]
}
```



## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808152216730.png" alt="image-20230808152216730" style="zoom:67%;" />

> 要么选,要么不选 01背包
>
> - 背包大小 sum的一半...........

```go
func canPartition(nums []int) bool {
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 == 1 {
		return false
	}
	dp := make([]int, sum/2+1)
	for i := 0; i < len(nums); i++ {
		for j := sum / 2; j >= nums[i]; j-- {
			dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
		}
	}
	return dp[sum/2] == sum/2
}
```



## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

**<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808155844043.png" alt="image-20230808155844043" style="zoom:67%;" />**

> 这是一个两个维度的01背包问题!!!
>
> - 递推中使用max 是符合题目中的最多/最少
> - 直接相加, 是必须装满的

```go
func findMaxForm(strs []string, m int, n int) int {
	dp := make([][]int, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]int, n+1)
	}

	for _, str := range strs {
		cnt0 := strings.Count(str, "0")
		cnt1 := strings.Count(str, "1")
		for i := m; i >= cnt0; i-- {
			for j := n; j >= cnt1; j-- {
				dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1]+1)
			}
		}
	}
	return dp[m][n]
}
```









## [494. 目标和](https://leetcode.cn/problems/target-sum/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808154045956.png" alt="image-20230808154045956" style="zoom:67%;" />

> - `1 <= nums.length <= 20` 2^20 如何回溯呢???
>
> 选 & 不选
>
> - 不选就是+, 1
> - 选就是-1
> - 这就转换为0, 1 背包
> - 这个是选的方案树木, 而不是容量
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808154937610.png" alt="image-20230808154937610" style="zoom: 50%;" />

```go
func findTargetSumWays(nums []int, target int) int {
	sum := 0
	for _, num := range nums {
		sum += num
	}
    
    // 必须是非负偶数 Good
	if (target+sum)%2 == 1 || target+sum < 0 {
		return 0
	}

	bag := (target + sum) / 2
	dp := make([]int, bag+1)
	dp[0] = 1
	for i := 0; i < len(nums); i++ {
		for j := bag; j >= nums[i]; j-- {
			dp[j] += dp[j-nums[i]]
		}
	}
	return dp[bag]
}
```



## [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808153427088.png" alt="image-20230808153427088" style="zoom:67%;" />

> 石头分成两份
>
> - 两份尽可能是相等的
> - 一个sum/2的背包, 看最多能装多少

```go
func lastStoneWeightII(stones []int) int {
	sum := 0
	for _, num := range stones {
		sum += num
	}

	dp := make([]int, sum/2+1)
	for i := 0; i < len(stones); i++ {
		for j := sum / 2; j >= stones[i]; j-- {
			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
		}
	}
	return sum - dp[sum/2]*2
}
```



# 完全背包DP

## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808162941060.png" alt="image-20230808162941060" style="zoom:67%;" />

> 完全背包, 是从前向后的, 注意和普通背包的区别

```go
func change(amount int, coins []int) int {
	dp := make([]int, amount+1)
	dp[0] = 1
	for i := 0; i < len(coins); i++ {
		for j := coins[i]; j <= amount; j++ {
			dp[j] += dp[j-coins[i]] // 准确的要直接相加
		}
	}
	return dp[amount]
}
```

> 先遍历内容, 再遍历背包容量, 这样求得的是组合数
>
> 而先遍历容量, 再遍历物品, 这样求得的是排列数 (见下题 377 )

## [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808164500836.png" alt="image-20230808164500836" style="zoom:67%;" />

> 注意是排列数还是组合数哈哈哈
>
> - 注意dp[0] = 1 !!!!!!!!!
> - 不要忘记初始条件啊

```go
func combinationSum4(nums []int, target int) int {
	dp := make([]int, target+1)
	dp[0] = 1 // 这里呀!!!!!!!!!!
	for i := 0; i <= target; i++ {
		for j := 0; j < len(nums); j++ {
			if i >= nums[j] && dp[i] < math.MaxInt32-dp[i-nums[j]] {
				dp[i] += dp[i-nums[j]]
			}
		}
	}
	return dp[target]
}
```

> 如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808165727797.png" alt="image-20230808165727797" style="zoom:67%;" />

> 求个数, 组合数就可以了
>
> - min/max + 限制条件 就是背包装满
> - 求最小值, dp要初始化位超大只
> - 最大值, 初始化为0
> - 注意dp[0]的单独初始化

```go
func coinChange(coins []int, amount int) int {
	dp := make([]int, amount+1)
	for i := 0; i <= amount; i++ {
		dp[i] = math.MaxInt32
	}
	dp[0] = 0

	for i := 0; i < len(coins); i++ {
		for j := coins[i]; j <= amount; j++ {
			if dp[j-coins[i]] != math.MaxInt32 {
				dp[j] = min(dp[j], dp[j-coins[i]]+1)
			}
		}
	}
	if dp[amount] == math.MaxInt32 {
		return -1
	}
	return dp[amount]
}
```



## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808225558098.png" alt="image-20230808225558098" style="zoom:67%;" />

> 完全背包, 每个可以选择多次
>
> - 直接选择组合数, 更easy
> - 求最小值, 那么初始值最大, 注意dp[0]的初始值

```go
func numSquares(n int) int {
	// 获取完全平方数
	squard := []int{}
	for i := 1; i*i <= n; i++ {
		squard = append(squard, i*i)
	}

	// 完全背包
	dp := make([]int, n+1)
	for i := 1; i <= n; i++ {
		dp[i] = math.MaxInt32
	}

	for i := 0; i < len(squard) && squard[i] <= n; i++ {
		for j := squard[i]; j <= n; j++ {
			dp[j] = min(dp[j], dp[j-squard[i]]+1)
		}
	}
	return dp[n]
}
```









# 数位dp

## [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230805224209446.png" alt="image-20230805224209446" style="zoom:67%;" />

> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230805231323548.png" alt="image-20230805231323548" style="zoom: 67%;" />

## [面试题 17.06. 2出现的次数](https://leetcode.cn/problems/number-of-2s-in-range-lcci/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230805234120603.png" alt="image-20230805234120603" style="zoom:67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230805234314736.png" alt="image-20230805234314736" style="zoom:67%;" />

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230805234327669.png" alt="image-20230805234327669" style="zoom:67%;" />

```go
func numberOf2sInRange(n int) int {
	if n == 0 {
		return 0
	}
	digit := int(math.Log10(float64(n))) + 1 // 数字的位数

	// dp[i][0] = numberOf2sInRange(n % pow(10, i)) 保存0~n的1-i位组成的数包含2的个数
	// dp[i][1] = numberOf2sInRange(99..9) 保存i位均为9包含2的个数
	dp := make([][]int, digit+1)
	for i := 0; i < digit+1; i++ {
		dp[i] = make([]int, 2)
	}
	dp[1][1] = 1
	if n%10 >= 2 {
		dp[1][0] = 1
	}

	for i := 2; i <= digit; i++ {
		k := n / int(math.Pow10(i-1)) % 10
		dp[i][0] = k*dp[i-1][1] + dp[i-1][0]
		if k == 2 {
			dp[i][0] += n%int(math.Pow10(i-1)) + 1 // 当前这一位可以有很多2
		} else if k > 2 {
			dp[i][0] += int(math.Pow10(i - 1)) // 当前这意味可以有很多2
		}
		dp[i][1] = 10*dp[i-1][1] + int(math.Pow10(i-1)) //计算1-i位均为9的值包含2的个数
	}
	return dp[digit][0]
}
```



















# 系列题目

## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230724170401072.png" alt="image-20230724170401072" style="zoom:67%;" />

> 最基本的dp啦啦啦
>
> - 这个dp的数组表示和下面的不一样哈
> - 以下面的为准

```go
func maxProfit(prices []int) int {
	dp := make([]int, len(prices))
	res := 0
    // 记录最低价格
	dp[0] = prices[0]
	for i := 1; i < len(prices); i++ {
        // 看今天卖出价格怎么样(以今天之前最低价格买)
		res = max(res, prices[i]-dp[i-1])
        // 更新最低价格
		dp[i] = min(dp[i-1], prices[i])
	}
	return res
}  
```

> 但是这种方法更像是贪心
>
> 真正的dp
>
> - dp\[i][0] 表示第i天持有股票所得现金。
> - dp\[i][1] 表示第i天不持有股票所得最多现金
>
> - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp\[i - 1][0]
> - 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp\[i - 1][1] - prices[i]



## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230724171128803.png" alt="image-20230724171128803" style="zoom:67%;" />

> 可以买很多只股票
>
> 但是最多只能持有一只股票
>
> dp good

```go
func maxProfit(prices []int) int {
	dp := make([][]int, len(prices))
	for i := 0; i < len(prices); i++ {
		dp[i] = make([]int, 2)
	}
    // 0 当天有股票
    // 当天不持有
	dp[0][0] = -prices[0]
	dp[0][1] = 0

	for i := 1; i < len(prices); i++ {
        // 前一天持有, 今天不变
        // 前一天不持有, 今日买入
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        // 前一天不持有,今日不变
        // 前一天持有, 今日卖出
		dp[i][1] = max(dp[i-1][1], dp[i][0]+prices[i])
	}
	return dp[len(prices)-1][1]
}
```

## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230724220703670.png" alt="image-20230724220703670" style="zoom:67%;" />

> 最多只能卖两次
>
> 也可以交易一次或者不交易
>
> dp[i]
>
> - 0 一直不持有
> - 1 第一次购入
> - 2 第一次卖出
> - 3 第二次购入
> - 4 第二次卖出
> - 0 其实是没有用的
> - 滚动dp, 可以使用\[2][5]的来进行, 根据%2来进行判断是哪一个

```go
func maxProfit(prices []int) int {
	dp := make([][]int, len(prices))
	for i := 0; i < len(prices); i++ {
		dp[i] = make([]int, 5)
	}
    // 一天可以交易多次, 所以第一天就可以两次交易
	dp[0][1] = -prices[0]
	dp[0][3] = -prices[0]
	for i := 1; i < len(prices); i++ {
        // 第一次买入, 可以当天买入, 前一天买入当天不动
		dp[i][1] = max(-prices[i], dp[i-1][1])
        // 第一次卖出, 前一次卖出,今日不动, 在今日已第一次买入的情况下卖出
		dp[i][2] = max(dp[i-1][2], dp[i][1]+prices[i])
        // 第二次和第一次一样的
		dp[i][3] = max(dp[i-1][3], dp[i][2]-prices[i])
		dp[i][4] = max(dp[i-1][4], dp[i][3]+prices[i])
	}
	return dp[len(prices)-1][4]
}
```

## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230726154738003.png" alt="image-20230726154738003" style="zoom:67%;" />

> 这题使用滚动数组来计算哈哈哈

```go
func maxProfit(k int, prices []int) int {
	dp := make([][]int, 2)
    
    // 第一个代表啥都不干, 这样更方便
	for i := 0; i < 2; i++ {
		dp[i] = make([]int, 2*k+1)
	}
	
	// 第一天可以多次买入卖出
	for i := 1; i < 2*k+1; i += 2 {
		dp[0][i] = -prices[0]
	}
	
    // 滚动数组
	for i := 1; i < len(prices); i++ {
		for j := 1; j < 2*k+1; j += 2 {
			dp[i%2][j] = max(dp[(i-1)%2][j-1]-prices[i], dp[(i-1)%2][j])
			dp[i%2][j+1] = max(dp[(i-1)%2][j]+prices[i], dp[(i-1)%2][j+1])
		}
	}
    return dp[(len(prices)-1)%2][2*k]
}
```



## [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808232151413.png" alt="image-20230808232151413" style="zoom:67%;" />

> 状态
>
> - 不持有
>   - 不持有/可买入 0
>   - 不持有/不可买入 1
> - 持有 2

```go
func maxProfit(prices []int) int {
	dp := make([][]int, 2)
	for i := 0; i < 2; i++ {
		dp[i] = make([]int, 3)
	}

	// 初始化第一天
	dp[0][2] = -prices[0]

	// dp
	for i := 1; i < len(prices); i++ {
		dp[i%2][0] = max(dp[(i+1)%2][0], dp[(i+1)%2][1])
		dp[i%2][1] = dp[(i+1)%2][2] + prices[i]
		dp[i%2][2] = max(dp[(i+1)%2][2], dp[(i+1)%2][0]-prices[i])
	}
	return max(dp[(len(prices)-1)%2][0], dp[(len(prices)-1)%2][1])
}
```



## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808233305985.png" alt="image-20230808233305985" style="zoom:67%;" />

```go
func maxProfit(prices []int, fee int) int {
	dp := make([]int, len(prices))
	res := 0
    // 记录最低价格
	dp[0] = prices[0]
	for i := 1; i < len(prices); i++ {
        // 看今天卖出价格怎么样(以今天之前最低价格买)
		res = max(res, prices[i]-dp[i-1])
        // 更新最低价格
		dp[i] = min(dp[i-1], prices[i])
	}
	return res
}  
```





## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230726121636870.png" alt="image-20230726121636870" style="zoom:67%;" />

> 梦开始的地方

```go
func rob(nums []int) int {
	if len(nums) == 1 {
		return nums[0]
	}

	dp := make([]int, len(nums))
	dp[0] = nums[0]
    // 透不透第一家
	dp[1] = max(nums[0], nums[1])

	for i := 2; i < len(nums); i++ {
		dp[i] = max(dp[i-1], dp[i-2]+nums[i])
	}

	return max(dp[len(dp)-1], dp[len(dp)-2])
}
```

## [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230802233322278.png" alt="image-20230802233322278" style="zoom:67%;" />

> 0-n-0 后面多加一个
>
> 分别计算 0-n 和 1-n-0 这两种方法
>
> 就ok啦 NONONONONONO
>
> 
>
> 要么偷第一家, 要么不偷, 这才是对的!!!!!!!!!!!!!!!!
>
> 如果每个dp都有值的话, 边界条件有点困难
>
> 如果让第一个dp就是为0的话, 那么就好办了

```go
func rob(nums []int) int {
	if len(nums) == 1 {
		return nums[0]
	}
	dp := make([]int, len(nums))

	dp[0] = 0
	dp[1] = nums[0]
	for i := 2; i < len(dp); i++ {
		dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])
	}
	res := dp[len(dp)-1]

	dp[0] = 0
	dp[1] = nums[1]
	for i := 2; i < len(dp); i++ {
		dp[i] = max(dp[i-1], dp[i-2]+nums[i])
	}
	return max(res, dp[len(dp)-1])
}
```

## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230808230721144.png" alt="image-20230808230721144" style="zoom:67%;" />

> 考虑监控二叉树这个方法
>
> - 从下到上, dfs返回两个值, 选这个点, 不选这个点

```go
func rob(root *TreeNode) int {
	var dfs func(root *TreeNode) (int, int)
	dfs = func(root *TreeNode) (int, int) {
		// 返回值分别为选这个节点的最大值, 不选这个节点的最大值
		if root == nil {
			return 0, 0
		}
		l1, l2 := dfs(root.Left)
		r1, r2 := dfs(root.Right)
		return root.Val + l2 + r2, max(l1, l2) + max(r1, r2)
	}
	res1, res2 := dfs(root)
	return max(res1, res2)
}
```





# 贪心

> 贪心算法一般分为如下四步：
>
> - 将问题分解为若干个子问题
> - 找出适合的贪心策略
> - 求解每一个子问题的最优解
> - 将局部最优解堆叠成全局最优解
>
> 这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。
>
> 做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。

## [134. 加油站](https://leetcode.cn/problems/gas-station/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230725130035903.png" alt="image-20230725130035903" style="zoom:67%;" />

> 1  2  3  4  5
>
> 3  4  5  1  2
>
> -2 -2 -2 3  3
>
> on2 遍历起点, 查看是不是走一圈油全是非负的
>
> 但是n2 肯定会超时, 进行优化, 还是超市

```go
func canCompleteCircuit(gas []int, cost []int) int {
	n := len(gas)

	// 获取差值
	for i := 0; i < n; i++ {
		cost[i] = gas[i] - cost[i]
	}

	// 遍历起点
	for startIdx := 0; startIdx < n; startIdx++ {
		// 一圈的油
		sum := 0
		nowIdx := startIdx
		cnt := n
		flag := true
		for cnt > 0 {
			// 尝试跳过太多无关的不消耗汽油的
			if cost[nowIdx%n] == 0 {
				nowIdx += 1
				cnt--
				continue
			}
			sum += cost[nowIdx%n]
			if sum < 0 {
				flag = false
				break
			} else {
				nowIdx += 1
				cnt -= 1
			}
		}
		if flag {
			return nowIdx % n
		}
	}
	return -1
}
```

> 必须只能一次遍历, 这个是底线
>
> 假设从x加油站出发经过z加油站最远能到达y加油站，那么从z加油站直接出发，不可能到达y下一个加油站。因为从x出发到z加油站时肯定至少还有存储的油，这都到不了y的下一站，而直接从z出发刚开始是没有存储的油的，所以更不可能到达y的下一站。
>
> 在发现了这一个性质后，算法就很清楚了：我们首先检查第 0 个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查

```go
func canCompleteCircuit(gas []int, cost []int) int {
	n := len(gas)
	startIdx := 0 // 从第几个加油站开始

	for startIdx < n {
		// 记录从这个加油站开始的油耗
		sum := gas[startIdx] - cost[startIdx]
		// 记录这个加油真能往后走多少个, 至少得往后走一个(当前失败)
		cnt := 1
		if sum < 0 {
			startIdx += cnt // 往后走, 到第一个无法到达的加油站
			continue
		}

		for sum >= 0 && cnt < n {
			sum += gas[(startIdx+cnt)%n] - cost[(startIdx+cnt)%n]
			cnt += 1
		}

		if sum >= 0 && cnt >= n {
			return startIdx // 走完了
		} else {
			startIdx += cnt // 往后走, 到第一个无法到达的加油站
			continue        //sum < 0
		}
	}
	return -1
}
```



> 亏空最严重的一个点必须放在最后一步走，等着前面剩余的救助
>
> 1. 首先判断总gas能不能大于等于总cost，如果总gas不够，一切都白搭对吧（总（gas- cost）不用单独去计算，和找最低点时一起计算即可，只遍历一次）；
> 2. 再就是找总（gas-cost）的最低点，不管正负（当然如果最低点都是正的话那肯定能跑完了）；
> 3. 找到最低点后，如果有解，那么解就是最低点的下一个点，因为总（gas-cost）是大于等于0的，所以前面损失的gas我从最低点下一个点开始都会拿回来！（此处@小马哥！“我要争一口气，不是想证明我了不起。我是要告诉人家，我失去的东西一定要拿回来！”），别管后面的趋势是先加后减还是先减后加，最终结果我是能填平前面的坑的。
>
> 但是如果是 0000000009 1111111110 很可能会超时, 切不好控制
>
> 不如下面的写法

一上一下两种方法, 都比题解的要好啊

> 如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。
>
> i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。
>
> 那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？
>
> 如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。
>
> 那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 curSum是不会小于零呢？
>
> **那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。
>
> 
>
> 这个其实就是题解的方法, 只是编码比我的好看太多了, fk

```go
// 可以走到结尾, 代表富裕油可以填平前面的差值
func canCompleteCircuit(gas []int, cost []int) int {
	curSum := 0
	totalSum := 0
	start := 0
	for i := 0; i < len(gas); i++ {
		curSum += gas[i] - cost[i]
		totalSum += gas[i] - cost[i]
		if curSum < 0 {
			start = i + 1
			curSum = 0
		}
	}
    // 油量不够
	if totalSum < 0 {
		return -1
	}
    // 油量够得
	return start
}
```



## [135. 分发糖果](https://leetcode.cn/problems/candy/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230725111836131.png" alt="image-20230725111836131" style="zoom:67%;" />

> 贪心第一题
>
> 这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。
>
> 此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果
>
> **所以确定左孩子大于右孩子的情况一定要从后向前遍历！**(可以用到第一轮的结果)
>
> 
>
> 那么本题我采用了两次贪心的策略：
>
> - 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
> - 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。

```go
func candy(ratings []int) int {
	candies := make([]int, len(ratings))
	length := len(ratings)

	// 先每个人分一个
	for i := 0; i < length; i++ {
		candies[i] = 1
	}

	// 从左向右, 比前一个人多, 就多给
	for i := 1; i < length; i++ {
		if ratings[i] > ratings[i-1] && candies[i] <= candies[i-1] {
			candies[i] = candies[i-1] + 1
		}
	}

	// 从右向左
	for i := length - 2; i >= 0; i-- {
		if ratings[i] > ratings[i+1] && candies[i] <= candies[i+1] {
			candies[i] = candies[i+1] + 1
		}
	}

	res := 0
	for _, num := range candies{
		res += num
	}
	return res
}
```

> 如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 pre+1个糖果即可。
>
> 否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。
>
> - 我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。
>
> - 同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。

```go
func candy(ratings []int) int {
	n := len(ratings)
	ans, inc, dec, pre := 1, 1, 0, 1
	for i := 1; i < n; i++ {
		if ratings[i] >= ratings[i-1] {
			dec = 0
			if ratings[i] == ratings[i-1] {
				pre = 1
			} else {
				pre++
			}
			ans += pre
			inc = pre
		} else {
			dec++
			// 同时注意当当前的递减序列长度和上一个递增序列等长时，
			// 需要把最近的递增序列的最后一个同学也并进递减序列中。
			if dec == inc {
				dec++
			}
			ans += dec
			pre = 1
		}
	}
	return ans
}
```

## [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

![image-20230809223037997](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809223037997.png)

> 双指针法
>
> - 每个孩子如果能满足, 都被能满足的最小饼干满足
> - 排序+双指针的贪心法

```go
func findContentChildren(g []int, s []int) (ans int) {
    sort.Ints(g)
    sort.Ints(s)
    m, n := len(g), len(s)
    for i, j := 0, 0; i < m && j < n; i++ {
        for j < n && g[i] > s[j] {
            j++
        }
        if j < n {
            ans++
            j++
        }
    }
    return
}
```

## [517. 超级洗衣机](https://leetcode.cn/problems/super-washing-machines/)

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809223529116.png" alt="image-20230809223529116" style="zoom:67%;" />

> 这种一定要自己多多模拟
>
> <img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230809224848083.png" alt="image-20230809224848083" style="zoom:67%;" />
>
> 
>
> 用当前值减去平均值【差值】，就是每个洗衣机要传入或者传出的数量，正数表示要传出，负数表示要传入 对于第[i]个洗衣机来说，左边要传入或者传出的数量，就是左边所有洗衣机的差值之和，为正表示左边有剩余，需要传到右边，为负表示左边不够，需要右边传过来，不管哪种情况，都要经过[i]节点，算作【流量】 差值 与 流量 的最大值，就是当前洗衣机要传入或者传出的数量 遍历所有洗衣机，找出最大值，即为最少次数
>
> 根据贪心的思想，每件衣服一旦出发之后，就马上往目的地走一刻也不停留，先出发的衣服会被派到更远的地方去，而不是中途逗留。
>
> - 组内和组间可以同步进行的, 所以两者取最大

```go
func findMinMoves(machines []int) (ans int) {
	tot := 0
	for _, v := range machines {
		tot += v
	}
	n := len(machines)
	if tot%n > 0 {
		return -1
	}
	avg := tot / n
	sum := 0
	for _, num := range machines {
		num -= avg
		sum += num
		ans = max(ans, max(abs(sum), num))
	}
	return
}
```





# 区间DP

## P1775 石子合并（弱化版）

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230830164550643.png" alt="image-20230830164550643" style="zoom:67%;" />

> 令`dp[i][j]`表示区间`[i,j]`的最小价值。
>
> 不妨从终点考虑问题，即结果为两个子区间合并的最小值再加上合并需要的代价即可。
>
> 枚举两个子区间，即枚举这个区间的中间点k，使这个区间被分为`[i,k]`和`[k+1,j]`两个区间，取一遍最小值加上合并的即为当前区间所求。
>
> 至于合并的代价，用前缀和即可。
>
> - dp之间加入循环求最小值, 也别想太多

```py
from sys import stdin, stdout

n = int(stdin.readline())
nums = [0] + list(map(int, stdin.readline().strip().split()))

dp = [[1e6 for _ in range(n + 1)] for _ in range(n + 1)]
s = [0 for _ in range(n + 1)]
for i in range(1, n + 1):
    s[i] = s[i - 1] + nums[i]
    dp[i][i] = 0

for length in range(2, n + 1):
    for i in range(1, n - length + 1 + 1):
        j = i + length - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1])
print(dp[1][n])
```



## P1880 [NOI1995] 石子合并

<img src="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230830165555204.png" alt="image-20230830165555204" style="zoom:67%;" />

```python
from sys import stdin, stdout

n = int(stdin.readline())
nums = list(map(int, stdin.readline().strip().split()))
nums = [0] + nums + nums

dp1 = [[1e9 for _ in range(2 * n + 1)] for _ in range(2 * n + 1)]
dp2 = [[-1e9 for _ in range(2 * n + 1)] for _ in range(2 * n + 1)]

s = [0 for _ in range(2 * n + 1)]
for i in range(1, 2 * n + 1):
    s[i] = s[i - 1] + nums[i]
    dp1[i][i] = 0
    dp2[i][i] = 0

for length in range(2, 2 * n + 1):
    for i in range(1, 2 * n - length + 1 + 1):
        j = i + length - 1
        for k in range(i, j):
            dp1[i][j] = min(dp1[i][j], dp1[i][k] + dp1[k + 1][j] + s[j] - s[i - 1])
            dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k + 1][j] + s[j] - s[i - 1])

min_res = 1e9
max_res = -1e9
for i in range(1, n + 1):
    min_res = min(min_res, dp1[i][i + n - 1])
    max_res = max(max_res, dp2[i][i + n - 1])
print(min_res, max_res, sep='\n')
```



















