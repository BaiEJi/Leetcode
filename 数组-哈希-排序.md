# 哈希

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230714160652966.png" alt="image-20230714160652966" style="zoom: 67%;" />

> 对于idx=0 的判断, 默认不存在, map也会返回0
>
> - 可以idx记录的时候 + 1
> - 可以使用ok来进行判断

``` go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    // for range 也可以的
    for i:=0; i<len(nums); i++{
        if _, ok := m[target- nums[i]]; ok{
            return []int{m[target- nums[i]], i}
        }
        m[nums[i]] = i
    }
    return []int{0,0}
}
```

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230714163640024.png" alt="image-20230714163640024" style="zoom:67%;" />

> 双指针 + 滑窗 + hash
>
> - 短路操作, 先判断长度, 尤其是在循环里面
> - 短路操之后再跟一个长度判断跳出循环, 这样就免去跳两层了

```go
func lengthOfLongestSubstring(s string) int {
	if len(s) == 0 {
		return 0
	}
	ret, left, right := 0, 0, 0
	m := make(map[byte]int)

	for {
		for right < len(s) && m[s[right]] == 0 {
			m[s[right]] += 1
			right += 1
		}
		if right-left > ret {
			ret = right - left
		}
		if right >= len(s) {
			break
		}

		for m[s[right]] != 0 {
			m[s[left]] -= 1
			left += 1
		}
	}
	return ret
}
```

## [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718111446608.png" alt="image-20230718111446608" style="zoom:67%;" />

> 直接行, 列, 格子哈希
>
> 这样分别哈希就是时间会久一点
>
> 可以多建立几个哈希表, 来一次遍历就ok(见37题)

```go
func isValidSudoku(board [][]byte) bool {
	// 行
	for i := 0; i < 9; i++ {
		m := make(map[byte]int)
		for j := 0; j < 9; j++ {
			if board[i][j] != '.' {
				if m[board[i][j]] != 0 {
					return false
				}
				m[board[i][j]] = 1
			}
		}
	}
	// 列
	for i := 0; i < 9; i++ {
		m := make(map[byte]int)
		for j := 0; j < 9; j++ {
			if board[j][i] != '.' {
				if m[board[j][i]] != 0 {
					return false
				}
				m[board[j][i]] = 1
			}
		}
	}
	// 9个格子
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			m := make(map[byte]int)
			for row := i * 3; row < i*3+3; row++ {
				for column := j * 3; column < j*3+3; column++ {
					if board[row][column] != '.' {
						if m[board[row][column]] != 0 {
							return false
						}
						m[board[row][column]] = 1
					}
				}
			}
		}
	}
	return true
}
```

## [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718194225639.png" alt="image-20230718194225639" style="zoom:67%;" />

> 做过, 但是忘了fuck
>
> 遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1。  => 6666666666666
>
> 
>
> 这就是原地哈希的一种方式, 要注意映射条件

```go
func firstMissingPositive(nums []int) int {
	for i := 0; i < len(nums); i++ {
		// 交换直至不符合条件
		// 为了防止[1] 这种报错, idx与数字的映射关系要减一
		for nums[i] > 0 && nums[i] <= len(nums) && nums[nums[i]-1] != nums[i] {
			nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
		}
	}
	for i := 0; i < len(nums); i++ {
		if i+1 != nums[i] {
			return i + 1
		}
	}
	return len(nums) + 1
}
```

## [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718200217454.png" alt="image-20230718200217454" style="zoom:67%;" />

> 直接bitmap作为Key就ok啦, Good => No 有的会出现多次
>
> 在美版leetcode上看到大神的思路，用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。（这个用质数表示真的很骚啊！！!）
>
> 
>
> 常见的解法
>
> - 字符串排序
> - 字母计数!!!!(array可以作为map的key!!!!!)

```go
func groupAnagrams(strs []string) [][]string {
	const MOD = 97755331
	prime := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101}
	m := make(map[int][]string)
	for _, s := range strs {
		key := 1
		for _, c := range s {
			key = (key * prime[int(c)-int('a')]) % MOD
		}
		m[key] = append(m[key], s)
	}
	res := make([][]string, 0)
	for _, v := range m {
		res = append(res, v)
	}
	return res
}
```



## [187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726002944429.png" alt="image-20230726002944429" style="zoom:67%;" />

> 滚动哈希呗
>
> 使用两个hash, 更确定啦
>
> - 但是这样做的意义在哪里呢? 直接使用哈希存放字符串不就行了????

```go
func findRepeatedDnaSequences(s string) []string {
	if len(s) < 10 {
		return nil
	}
	const MOD1, MOD2 = 131, 151
	m1 := make(map[string]int)
	m2 := make(map[string]int)

	res := make([]string, 0)

	hash1, base1, hash2, base2 := 0, 1, 0, 1
	for i := 0; i < 10; i++ {
		hash1 = hash1*MOD1 + int(s[i]-'A')
		base1 *= MOD1
		hash2 = hash2*MOD2 + int(s[i]-'A')
		base2 *= MOD2
	}
	base1, base2 = base1/MOD1, base2/MOD2

	m1[s[:10]] = 1
	m2[s[:10]] = 1

	for i := 10; i < len(s); i++ {
		hash1 = (hash1-base1*(int(s[i-9]-'A')))*MOD1 + int(s[i]-'A')
		hash2 = (hash2-base2*(int(s[i-9]-'A')))*MOD2 + int(s[i]-'A')
		if m1[s[i-9:i+1]] == 1 && m2[s[i-9:i+1]] == 1 {
			res = append(res, s[i-9:i+1])
			m1[s[i-9:i+1]] = 2
			m2[s[i-9:i+1]] = 2
		} else if m1[s[i-9:i+1]] == 0 || m2[s[i-9:i+1]] == 0 {
			m1[s[i-9:i+1]] = 1
			m2[s[i-9:i+1]] = 1
		}
	}
	return res
}
```

> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726004642736.png" alt="image-20230726004642736" style="zoom:67%;" />

```go
func findRepeatedDnaSequences(s string) (ans []string) {
	const L = 10
	var bin = map[byte]int{'A': 0, 'C': 1, 'G': 2, 'T': 3}
	
	n := len(s)
	if n <= L {
		return
	}
	x := 0
	for _, ch := range s[:L-1] {
		x = x<<2 | bin[byte(ch)]
	}
	cnt := map[int]int{}
	for i := 0; i <= n-L; i++ {
		x = (x<<2 | bin[s[i+L-1]]) & (1<<(L*2) - 1)
		cnt[x]++
		if cnt[x] == 2 {
			ans = append(ans, s[i:i+L])
		}
	}
	return ans
}
```

## [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230727105322918.png" alt="image-20230727105322918" style="zoom:67%;" />

> 常量级别的
>
> - 原地哈希????/
> - 二分法 nlogn
>   - 注意二分的边界问题, 一定要细心
>   - 二分可以不用写一个函数, 写一个for就ok啦

```go
func twoSum(numbers []int, target int) []int {
	n := len(numbers)

	binarysearch := func(i, j, t int) int {
		l, r := i, j
		for l < r {
			mid := l + (r-l)/2
			if numbers[mid] < t {
				l = mid + 1
			} else {
				r = mid
			}
		}
		if l < n && numbers[l] == t {
			return l
		} else {
			return -1
		}
	}

	for idx := 0; idx < n; idx++ {
		t := target - numbers[idx]
		if binarysearch(idx+1, n, t) != -1 {
			return []int{idx + 1, binarysearch(idx+1, n, t) + 1}
		}
	}
	return nil
}
```

> 双指针法 fkfkfk
>
> - 看到有序, 就要想到二分和双指针....
> - 而且双指针前提是只有一个结果!!!

```go
func twoSum(numbers []int, target int) []int {
	l, r := 0, len(numbers)
	for l < r {
		s := numbers[l] + numbers[r]
		if s == target {
			return []int{l + 1, r + 1}
		} else if s < target {
			l++
		} else {
			r--
		}
	}
	return nil
}
```







## [169. 多数元素](https://leetcode.cn/problems/majority-element/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726102507877.png" alt="image-20230726102507877" style="zoom:67%;" />

> 1. 哈希表维护
> 2. sort 之后直接选取 n/2

```go
func majorityElement(nums []int) int {
	m := make(map[int]int)
	for _, num := range nums {
		m[num]++
	}
	res := 0
	resV := 0
	for k, v := range m {
		if v > resV {
			res, resV = k, v
		}
	}
	return res
}
```

> 3. Boyer-Moore 投票算法
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726103134291.png" alt="image-20230726103134291" style="zoom:50%;" />
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726103228085.png" alt="image-20230726103228085" style="zoom:50%;" />

```go
func majorityElement(nums []int) int {
	cnt := 0
	candidate := 10000000001
	for _, num := range nums {
		if cnt == 0 {
			candidate = num
			cnt = 1
		} else {
			if num == candidate {
				cnt++
			} else {
				cnt--
			}
		}
	}
	return candidate
}
```

## [229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806103826970.png" alt="image-20230806103826970" style="zoom:67%;" />

> Boyer-Moore 投票算法 多少都可以
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806105031998.png" alt="image-20230806105031998" style="zoom:67%;" />
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806105055128.png" alt="image-20230806105055128" style="zoom:67%;" />
>
> 最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3 遍历结束后选出了两个候选人，但是这两个候选人是否满足>n/3，还需要再遍历一遍数组，找出两个候选人的具体票数
>

```go
func majorityElement(nums []int) (res []int) {
	element1, element2 := 0, 0 // 元素
	vote1, vote2 := 0, 0       // 元素的个数

	for _, num := range nums {
		if vote1 > 0 && num == element1 { // 如果该元素为第一个元素，则计数加1
			vote1++
		} else if vote2 > 0 && num == element2 { // 如果该元素为第二个元素，则计数加1
			vote2++
		} else if vote1 == 0 { // 选择第一个元素
			element1 = num
			vote1++
		} else if vote2 == 0 { // 选择第二个元素, 若是选择了第一个那就不是选择第二个了
			element2 = num
			vote2++
		} else { // 如果三个元素均不相同，则相互抵消1次
			vote1--
			vote2--
		}
	}

	cnt1, cnt2 := 0, 0
	for _, num := range nums {
		if vote1 > 0 && num == element1 {
			cnt1++
		}
		if vote2 > 0 && num == element2 {
			cnt2++
		}
	}

	// 检测元素出现的次数是否满足要求
	if vote1 > 0 && cnt1 > len(nums)/3 {
		res = append(res, element1)
	}
	if vote2 > 0 && cnt2 > len(nums)/3 {
		res = append(res, element2)
	}
	return res
}
```

















## [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726111436101.png" alt="image-20230726111436101" style="zoom:67%;" />

> - 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
> - 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？
>
> 1. 直接开一个额外的数组, 使用下标映射填充
> 2. 直接append前面到后面

```go
func rotate(nums []int, k int) {
    // 必须余, 要不然会有负数索引
	k %= len(nums)
    // 必须要copy才可以哈
	copy(nums, append(nums[len(nums)-k:], nums[:len(nums)-k]...))
}
```

> 就是python的deque的rotate的源码啊
>
> 我怎么忘了呢?????????????????

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726112548075.png" alt="image-20230726112548075" style="zoom:67%;" />

```go
func rotate(nums []int, k int) {
	reverse := func(a []int) {
		for i, n := 0, len(a); i < n/2; i++ {
			a[i], a[n-1-i] = a[n-1-i], a[i]
		}
	}

	k %= len(nums)
	reverse(nums)
	reverse(nums[:k])
	reverse(nums[k:])
}
```

## [217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230802205638007.png" alt="image-20230802205638007" style="zoom:67%;" />

> 如何减少空间使用呢????
>
> - 解法1：哈希法
> - 解法2：先排序，然后对比相邻元素 (空间使用的少)

```go
func containsDuplicate(nums []int) bool {
	m := make(map[int]int)
	for _, num := range nums {
		if m[num] == 0 {
			m[num] = 1
		} else {
			return true
		}
	}
	return false
}
```

## [219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230802211521168.png" alt="image-20230802211521168" style="zoom:67%;" />

> 大小为k的滑动窗口
>
> 在滑动窗口里面进行哈希.....

```go
func containsNearbyDuplicate(nums []int, k int) bool {
	set := map[int]bool{}
	for i := 0; i < len(nums); i++ {
        // 这种滑动窗口的写法是真的挺好的
        // 把初始化放在了一个循环里面
		if i > k {
			set[nums[i-k-1]] = false
		}
		if set[nums[i]] {
			return true
		}
		set[nums[i]] = true
	}
	return false
}
```



## [1001. 网格照明](https://leetcode.cn/problems/grid-illumination/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803220044587.png" alt="image-20230803220044587" style="zoom:67%;" />

> 四个哈希
>
> - 行
> - 列
> - 左对角
> - 右对角
>
> 一个哈希
>
> - 行-列 因为只是周围的八个点, 所以直接遍历这9个点更直接

 ```go
 func gridIllumination(n int, lamps [][]int, queries [][]int) []int {
 	type pair struct{ x, y int }
 	// x-y x+y
 	row, column, left, right := map[int]int{}, map[int]int{}, map[int]int{}, map[int]int{}
 	pos := map[pair]bool{}
 	res := make([]int, len(queries))
 
 	// 保存所偶状态
 	for _, lamp := range lamps {
 		if pos[pair{x: lamp[0], y: lamp[1]}] {
 			continue
 		}
 		row[lamp[0]]++
 		column[lamp[1]]++
 		left[lamp[0]+lamp[1]]++
 		right[lamp[0]-lamp[1]]++
 		pos[pair{x: lamp[0], y: lamp[1]}] = true
 	}
 
 	// 遍历每个请求
 	for idx, querie := range queries {
 		x, y := querie[0], querie[1]
 		if row[x] != 0 || column[y] != 0 || left[x+y] != 0 || right[x-y] != 0 {
 			res[idx] = 1
 		}
 
 		// 关闭9个等
 		for i := x - 1; i <= x+1; i++ {
 			for j := y - 1; j <= y+1; j++ {
 				if pos[pair{x: i, y: j}] {
 					row[i]--
 					column[j]--
 					left[i+j]--
 					right[i-j]--
 					pos[pair{x: i, y: j}] = false
 				}
 			}
 		}
 	}
 	return res
 }
 ```



## [228. 汇总区间](https://leetcode.cn/problems/summary-ranges/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230805221813139.png" alt="image-20230805221813139" style="zoom:67%;" />

> 双指针要灵活运用!!!!!!!!!, 不要局限于定式

```go
func summaryRanges(nums []int) []string {
	res := make([]string, 0)
	l, r := 0, 1
	for l < len(nums) {
		for r < len(nums) && nums[r] == nums[r-1]+1 {
			r += 1
		}
		if l == r-1 {
			res = append(res, strconv.Itoa(nums[l]))
		} else {
			res = append(res, fmt.Sprintf("%d->%d", nums[l], nums[r-1]))
		}
		l, r = r, r+1
	}
	return res
}
```

## [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230830151850940.png" alt="image-20230830151850940" style="zoom:67%;" />

> - 题目说明白呀
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230830152142921.png" alt="image-20230830152142921" style="zoom:50%;" />

```go
func intersect(nums1 []int, nums2 []int) []int {
	res := []int{}
	cnt := make(map[int]int)
	for _, num := range nums1 {
		cnt[num]++
	}
	for _, num := range nums2 {
		if cnt[num] != 0 {
			res = append(res, num)
			cnt[num]--
		}
	}
	return res
}
```



## [442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230830153444069.png" alt="image-20230830153444069" style="zoom:67%;" />

> - 我想的是一直使用for进行交换, 大家都移动到位置上
> - 其实只要找到重复就可以啊!!!!!!!
>   - 只有两种, 出现过, 没出现
>   - 使用正负号就可以啦

```go
func findDuplicates(nums []int) []int {
	res := []int{}
	for i := 0; i < len(nums); i++ {
		t := abs(nums[i])
		if nums[t-1] > 0 {
			nums[t-1] *= -1
		} else {
			res = append(res, t)
		}
	}
	return res
}
```



## [324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230904152721314.png" alt="image-20230904152721314" style="zoom:67%;" />

> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230904152732338.png" alt="image-20230904152732338" style="zoom:67%;" />

```go
func wiggleSort(nums []int) {
	n := len(nums)
	k := n / 2

	// 1, 三路快拍求得中位数
	var quickPartition func(start, end, target int)
	quickPartition = func(start, end, target int) {
		randNum := rand.Intn(end-start+1) + start
		base := nums[randNum]
		nums[start], nums[randNum] = nums[randNum], nums[start]
		idx := start
		for i := start + 1; i <= end; i++ {
			if nums[i] < base {
				nums[idx+1], nums[i] = nums[i], nums[idx+1]
				idx += 1
			}
		}
		nums[start], nums[idx] = nums[idx], nums[start]
		if idx < target {
			quickPartition(idx+1, end, target)
		} else if idx > target {
			quickPartition(start, idx-1, target)
		}
	}
	quickPartition(0, len(nums)-1, k)
	numK := nums[k]

	// 2. 荷兰国旗, 分为三部分, 小于 等于 大于
	ptr0, ptr2 := 0, len(nums)-1
	for i := 0; i <= ptr2; i++ {
		for i <= ptr2 && nums[i] > numK {
			nums[i], nums[ptr2] = nums[ptr2], nums[i]
			ptr2 -= 1
		}
		if nums[i] < numK {
			nums[i], nums[ptr0] = nums[ptr0], nums[i]
			ptr0 += 1
		}
	}

	// 3. 填入数据, 从大到小
	if n%2 == 1 {
		k++
	}
	nums1 := nums[:k]
	nums2 := nums[k:]

	res := make([]int, n)
	for i := 0; i < len(nums1); i++ {
		res[i*2] = nums1[len(nums1)-i-1]
	}
	for i := 0; i < len(nums2); i++ {
		res[i*2+1] = nums2[len(nums2)-i-1]
	}

	for i := 0; i < n; i++ {
		nums[i] = res[i]
	}
}
```



## [846/87. 一手顺子](https://leetcode.cn/problems/hand-of-straights/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231205105111211.png" alt="image-20231205105111211" style="zoom:80%;" />

> 哈希表计数, 这个题目乍一看挺唬人, 其实就那样

```go
func isNStraightHand(hand []int, groupSize int) bool {
	if len(hand)%groupSize != 0 {
		return false
	}

	sort.Ints(hand)          // 先排序
	set := make(map[int]int) //记录每一个数字的次数
	for _, num := range hand {
		set[num]++
	}

	for _, start := range hand {
		if set[start] != 0 { // 如果这个数还没用过
			for i := 0; i < groupSize; i++ { // 这一组必须有
				if set[start+i] != 0 {
					set[start+i]--
				} else {
					return false
				}
			}
		}
	}
	return true
}
```





## ~~[859/90. 亲密字符串](https://leetcode.cn/problems/buddy-strings/)~~

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231213102506341.png" alt="image-20231213102506341" style="zoom:67%;" />

> - 就是多注意条件, 别想当然
>   - 不一样至少得有一个字母至少出现两次
>   - 可以使用数组进行替代哈希表
> - 改用两个hash就2个hash, 别有心理负担

```go
func buddyStrings(s string, goal string) bool {
    if len(s) != len(goal){
        return false
    }

    ms := make(map[byte]int, 0)
    mg := make(map[byte]int, 0)
    flag := false
    cnt := 0
    for i:=0; i<len(s); i++{
        if s[i] != goal[i]{
            cnt ++
        }
        ms[s[i]] ++
        mg[goal[i]]++
        
    }
    for i:=0; i<len(s); i++{
        if ms[s[i]] != mg[s[i]]{
            return false
        }
        if ms[s[i]] >= 2 {
            flag = true
        }
    }
    return cnt==2 || (cnt==0 && flag)
}
```











# 前后缀

## [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806161352340.png" alt="image-20230806161352340" style="zoom:67%;" />

> 想法: 保存所以的乘积, 做除法
>
> - 若是有0, 则失败
>
> 同时保存前后缀进行相乘就ok
>
> - 先计算前缀, 再计算后缀, 省空间

```go
func productExceptSelf(nums []int) []int {
	leftCul := 1
	res := make([]int, len(nums))

	// res 先保存前缀
	for l := 0; l < len(nums); l++ {
		res[l] = leftCul
		leftCul *= nums[l]
	}

	// 乘上后缀
	rightCul := 1
	for r := len(nums) - 1; r >= 0; r-- {
		res[r] *= rightCul
		rightCul *= nums[r]
	}

	return res
}
```



## P3397 地毯

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230829145850115.png" alt="image-20230829145850115" style="zoom:67%;" />

> 遍历地毯上的每一个点, 肯定是会超时的
>
> 所以要使用前缀
>
> - 使用的是二维差分的方法
> - -1 向后顺延一位

```c++
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> carpet(n, vector<int>(n + 1, 0));
    for (int i = 0; i < m; i++) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        for (int i = x1 - 1; i <= x2 - 1; i++) {
            carpet[i][y1 - 1]++;
            carpet[i][y2]--;
        }
    }

    int sum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            sum += carpet[i][j];
            cout << sum << " ";
        }
        sum += carpet[i][n];
        cout << endl;
    }
    return 0;
}
```

## **P2004 领地选择**

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230829150803363.png" alt="image-20230829150803363" style="zoom:67%;" />

> 前缀和记录所有已原点开始的方形的面积
>
> - 使用的是容斥求得的面积
> - 这样很good, 只需要遍历一次

```go
int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);
    int n, m, c;
    cin >> n >> m >> c;
    vector<vector<ll>> map(n + 1, vector<ll>(m + 1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int tmp;
            cin >> tmp;
            map[i][j] = tmp;
        }
    }

    for (int i = 2; i <= n; i++) map[i][1] += map[i - 1][1];
    for (int i = 2; i <= m; i++) map[1][i] += map[1][i - 1];
    for (int i = 2; i <= n; ++i) {
        for (int j = 2; j <= m; ++j) {
            map[i][j] =
                map[i][j] + map[i - 1][j] + map[i][j - 1] - map[i - 1][j - 1];
        }
    }

    ll res{LONG_LONG_MIN};
    int l{}, r{};
    for (int i = c; i <= n; i++) {
        for (int j = c; j <= m; ++j) {
            ll tmpRes =
                map[i][j] + map[i - c][j - c] - map[i][j - c] - map[i - c][j];
            if (tmpRes > res) {
                res = tmpRes;
                l = i - c + 1;
                r = j - c + 1;
            }
        }
    }
    cout << l << " " << r << endl;
    return 0;
}
```



## [1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230829151503135.png" alt="image-20230829151503135" style="zoom:67%;" />

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
		vector<int> after{0};
		vector<int> back{0};
		for(int i=0; i<cardPoints.size(); i++)
            after.push_back(after.back() + cardPoints[i]);
		for(int j=cardPoints.size()-1; j>=0; j--)
            back.push_back(back.back()+cardPoints[j]);		
		int res = 0;
		for(int i=0; i<=k; i++)
			res = max(res, after[i]+back[k-i]);
		return res;
    }
};
```

> 前后缀哦再K过大的时, 也不太行哈
>
> - n-k的滑动窗口求最小值, 反向思维哈

```c++
int maxScore(vector<int>& cardPoints, int k) {
		int sum{}, window{}, min_window{}, size=cardPoints.size();
		for(int i=0; i<size-k; i++)
			window += cardPoints[i];
		sum = window;
		min_window = window;
		
		for(int i=size-k; i<size; i++){
			sum += cardPoints[i];
			window = window - cardPoints[i-(size-k)] + cardPoints[i];
			min_window = min(window, min_window);
		}
		return sum - min_window;			
    }
```

## [1044. 最长重复子串](https://leetcode.cn/problems/longest-duplicate-substring/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230829151804259.png" alt="image-20230829151804259" style="zoom:67%;" />

> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230829152102077.png" alt="image-20230829152102077" style="zoom:67%;" />
>
> - 是对于最大的长度进行的二分查找

```go
func longestDupSubstring(s string) string {
	const BASE = 31
	n := len(s)
	h := make([]int64, n+10, n+10)    // 记录的是哈希值, 从0到当前
	base := make([]int64, n+10, n+10) // 记录的是权值
	base[0] = 1

	// 计算基数和害的值
	for i := 0; i < n; i++ {
		base[i+1] = base[i] * BASE
		h[i+1] = h[i]*BASE + int64(s[i]-'a')
	}

	// check 函数
	check := func(len int) string {
		set := make(map[int64]bool)
		for i := 1; i+len-1 <= n; i++ {
			j := i + len - 1
			cur := h[j] - h[i-1]*base[j-i+1]
			if set[cur] {
				return s[i-1 : j]
			}
			set[cur] = true
		}
		return ""
	}

	l, r := 0, n
	ans := ""
	for l < r {
		mid := l + (r-l)>>1
		tmp := check(mid)
		if tmp != "" {
			l = mid + 1
		} else {
			r = mid
		}
		if len(tmp) > len(ans) {
			ans = tmp
		}
	}
	return ans
}
```







# 双指针 & 滑动窗口

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230717095613025.png" alt="image-20230717095613025" style="zoom:67%;" />

> 与27一致, 双指针写法

```go
func removeDuplicates(nums []int) int {
	if nums == nil || len(nums) == 0 {
		return 0
	}
	if len(nums) == 1 {
		return 1
	}
	j := 0
	for i := 1; i < len(nums); i++ {
		if nums[i] != nums[j] {
			j += 1
			nums[j] = nums[i]
		}
	}
	return j + 1
}
```



## [27. 移除元素](https://leetcode.cn/problems/remove-element/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230716215339876.png" alt="image-20230716215339876" style="zoom:67%;" />

> 双指针的一种写法: 一个设置为值, 另一个作为循环变量更新值指针

```go
func removeElement(nums []int, val int) int {
	if len(nums) == 0 {
		return 0
	}
	j := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != val {
			nums[j] = nums[i]
			j += 1
		}
	}
	return j
}
```

## [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718091600854.png" alt="image-20230718091600854" style="zoom:67%;" />

> 我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
>
> 我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。
>
> - 在 尽可能靠右的低位 进行交换，需要 从后向前 查找
> - 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
> - 将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
>

算法过程

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718092248977.png" alt="image-20230718092248977" style="zoom:50%;" />

```go
func nextPermutation(nums []int) {
	if len(nums) <= 1 {
		return
	}
	i := len(nums) - 1

	// i 指向从后向前第一个升序
	for ; i >= 1; i-- {
		if nums[i-1] < nums[i] {
			i -= 1
			break
		}
	}
	// 找到最小交换的
	idx := -1
	tmp := math.MaxInt32
	for j := i + 1; j < len(nums); j++ {
		if nums[j] > nums[i] && nums[j]-nums[i] < tmp {
			tmp = nums[j] - nums[i]
			idx = j
		}
	}

	// 全降序, 从头来
	if idx == -1 {
		sort.Ints(nums)
		return
	}
	// 交换排序
	nums[i], nums[idx] = nums[idx], nums[i]
	sort.Ints(nums[i+1:])
	return
}
```

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718093828033.png" alt="image-20230718093828033" style="zoom:33%;" />



## [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230721092854597.png" alt="image-20230721092854597" style="zoom:67%;" />

> 荷兰国旗问题, 还是有难度的哈
>
> 必须得背会

```go
func sortColors(nums []int) {
	ptr0, ptr2 := 0, len(nums)-1
	for i := 0; i <= ptr2; i++ {
		for i <= ptr2 && nums[i] == 2 {
			nums[i], nums[ptr2] = nums[ptr2], nums[i]
			ptr2 -= 1
		}
		if nums[i] == 0 {
			nums[i], nums[ptr0] = nums[ptr0], nums[i]
			ptr0 += 1
		}
	}
}
```



## [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230721104004337.png" alt="image-20230721104004337" style="zoom:67%;" />

> ....这题诗真的easy
>
> 想好双指针都放在那里就ok了
>
> 与删除一个是一样的

```go
func removeDuplicates(nums []int) int {
	if len(nums) <= 2 {
		return len(nums)
	}

	l, r := 1, 2
	for r < len(nums) {
        // 这个够两个了
		if nums[r] == nums[l-1] {
			r++
		} else {
            // 新的数值, 都向右移动
			l++
			nums[l], nums[r] = nums[r], nums[l]
			r++
		}
	}
	return l + 1
}
```

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230721155129653.png" alt="image-20230721155129653" style="zoom:67%;" />

> 两个哈希表, 双指针移动就ok了
>
> - 不断增加`j`使滑动窗口增大，直到窗口包含了T的所有元素
> - 不断增加i使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值
> - 让`i`再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从**步骤一**开始执行，寻找新的满足条件的滑动窗口，如此反复，直到`j`超出了字符串S范围。
> - 我们用一个字典need来表示当前滑动窗口中需要的各元素的数量，一开始滑动窗口为空，用T中各元素来初始化这个need，当滑动窗口扩展或者收缩的时候，去维护这个need字典，例如当滑动窗口包含某个元素，我们就让need中这个元素的数量减1，代表所需元素减少了1个；当滑动窗口移除某个元素，就让need中这个元素的数量加1。
>   记住一点：need始终记录着当前滑动窗口下，我们还需要的元素数量，我们在改变i,j时，需同步维护need。
>   值得注意的是，只要某个元素包含在滑动窗口中，我们就会在need中存储这个元素的数量，如果某个元素存储的是负数代表这个元素是多余的。比如当need等于{'A':-2,'C':1}时，表示当前滑动窗口中，我们有2个A是多余的，同时还需要1个C。这么做的目的就是为了步骤二中，排除不必要的元素，数量为负的就是不必要的元素，而数量为0表示刚刚好。
> - 如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)O(k)的时间复杂度，k代表字典长度，最坏情况下，k可能等于len(S)。
>   其实这个是可以避免的，我们可以维护一个额外的变量needCnt来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。

```go
func minWindow(s string, t string) string {
	// 创建所需字典
	need := make(map[byte]int)
	needCnt := len(t)
	for i := 0; i < len(t); i++ {
		need[t[i]] += 1
	}

	// 双指针, 一个是循环变量, 另一个在循环里面更新
	l := 0
	res := []int{0, math.MaxInt32}

	for r := 0; r < len(s); r++ {
        // 这样就只是在t里面的有可能>0
		if need[s[r]] > 0 {
			needCnt -= 1
		}
		// 每个都减去
		need[s[r]] -= 1
		if needCnt == 0 {
			// 满足条件, l右移
			for {
                // 移动到了一个需要的
				if need[s[l]] == 0 {
					break
				}
				need[s[l]] += 1
				l += 1
			}
			// 更新
			if r-l < res[1]-res[0] {
				res[1], res[0] = r, l
			}

			// i 右移一位
			need[s[l]] += 1
			needCnt += 1
			l += 1
		}
	}
	if res[1] > len(s) {
		return ""
	}
	return s[res[0] : res[1]+1]
}
```



## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230802150236387.png" alt="image-20230802150236387" style="zoom:67%;" />

> 滑动窗口呗

```go
func minSubArrayLen(target int, nums []int) int {
	l, sum_now, res := 0, 0, math.MaxInt
	for r := 0; r < len(nums); r++ {
		sum_now += nums[r]
		if sum_now < target {
			continue
		}
		for sum_now-nums[l] >= target {
			sum_now -= nums[l]
			l++
		}
		res = min(res, r-l+1)
	}
	if res == math.MaxInt {
		return 0
	}
	return res
}
```



## [220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803132518266.png" alt="image-20230803132518266" style="zoom:67%;" />

> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803133725690.png" alt="image-20230803133725690" style="zoom:67%;" />
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803134420621.png" alt="image-20230803134420621" style="zoom:67%;" />
>
> 
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803135137513.png" alt="image-20230803135137513" style="zoom: 67%;" />
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803135323606.png" alt="image-20230803135323606" style="zoom:67%;" />

```go
func containsNearbyAlmostDuplicate(nums []int, k, t int) bool {
	getID := func(x, w int) int {
		if x >= 0 {
			return x / w
		}
		return (x+1)/w - 1
	}

	mp := map[int]int{}
	for i, x := range nums {
		id := getID(x, t+1)
		if _, has := mp[id]; has {
			return true
		}
		if y, has := mp[id-1]; has && abs(x-y) <= t {
			return true
		}
		if y, has := mp[id+1]; has && abs(x-y) <= t {
			return true
		}
		mp[id] = x
		if i >= k {
			delete(mp, getID(nums[i-k], t+1))
		}
	}
	return false
}
```

## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230830114731721.png" alt="image-20230830114731721" style="zoom:67%;" />

> 滑动窗口.....
>
> - 好就好再左边的指针可以临时超过右边的指针

```go

func findAnagrams(s string, p string) []int {
	ls, lp := len(s), len(p)
	res := []int{}
	if lp > ls { // 直接停止
		return res
	}
	cnt := make([]int, 26)
	for i := 0; i < lp; i++ { // 记录哈希
		cnt[p[i]-'a']++
	}
	l, r := 0, 0
	for r < ls {
		if cnt[s[r]-'a'] > 0 {
			cnt[s[r]-'a']--
			r++
			if r-l == lp {
				res = append(res, l)
			}
		} else {
			cnt[s[l]-'a']++
			l++
		}
	}
	return res
}
```



## [830/83. 较大分组的位置](https://leetcode.cn/problems/positions-of-large-groups/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231127214456393.png" alt="image-20231127214456393" style="zoom:67%;" />

> - 直接想法:双指针法
>   - 注意: 双指针一定是双层范围检验, 且第二层位域首处

```go
func largeGroupPositions(s string) [][]int {
	res := make([][]int, 0)
	left, right := 0, 0
	for right < len(s) {
		for right < len(s) && s[left] == s[right] {
			right++
		}
		if right-left > 2 {
			res = append(res, []int{left, right - 1})
		}
		left = right
	}
	return res
}
```

> - 另一种双指针写法
>   - 把左边的指针写在for循环里面, 但是第三个条件不写



## [832/84. 翻转图像](https://leetcode.cn/problems/flipping-an-image/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231129100736826.png" alt="image-20231129100736826" style="zoom:67%;" />> 

> - Go直接来就行了
>   - 使用异或很easy

````go
func flipAndInvertImage(image [][]int) [][]int {
	n := len(image)
	for i := 0; i < n; i++ {
		l, r := 0, n-1
		for l <= r {
			image[i][l], image[i][r] = image[i][r]^1, image[i][l]^1
			l, r = l+1, r-1
		}
	}
	return image
}
````

> - Py一行代码
>   - ==[[j^1 for j in i[::-1]] for i in image]==



## [838/85. 推多米诺](https://leetcode.cn/problems/push-dominoes/)

![image-20231201194739085](./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231201194739085.png)

> - 当然是使用双指针法来进行操作啦
>   - \[left\]\[\. * N]\[right\] 来进行双指针操作
>   - 左加L右加R不影响最后结果
>   - 而且每次区间处理加入结果集的只有左边界
>   - 左右边界不一样才进行处理, 要考虑所有的结果
>   - ==双指针右边界在for里面==

```go
func pushDominoes(dominoes string) string {
	dominoes = "L" + dominoes + "R"
	res := strings.Builder{}
	left := 0

	for right := 1; right < len(dominoes); right++ {
		if dominoes[right] == '.' {
			continue
		}
		res.WriteByte(dominoes[left])
		count := right - left - 1
		if dominoes[left] == dominoes[right] {
			res.WriteString(strings.Repeat(string(dominoes[left]), count))
		} else if dominoes[left] == 'L' && dominoes[right] == 'R' {
			res.WriteString(strings.Repeat(".", count))
		} else {
			res.WriteString(strings.Repeat(string(dominoes[left]), count/2))
			res.WriteString(strings.Repeat(".", count%2))
			res.WriteString(strings.Repeat(string(dominoes[right]), count/2))
		}
		left = right
	}
	return res.String()[1:]
}
```



## [844/87. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231205091506394.png" alt="image-20231205091506394" style="zoom:80%;" />

> - Golang中string不可变, 所以必须转换为数组才行
> - []切片之间是不可比较的!!!!!!!!!!
> - 双指针一个变量领一个循环 => Get
>   - 这个左指针是可以向左走的哈

```go
func backspaceCompare(s string, t string) bool {
	sByte, tByte := []byte(s), []byte(t)
	ls := 0
	for rs := 0; rs < len(s); rs++ {
		if sByte[rs] != '#' {
			sByte[ls] = sByte[rs]
			ls++
		} else if ls != 0 {
			ls--
		}
	}

	lt := 0
	for rt := 0; rt < len(t); rt++ {
		if tByte[rt] != '#' {
			tByte[lt] = tByte[rt]
			lt++
		} else if lt != 0 {
			lt--
		}
	}
	
	return string(sByte[:ls]) == string(tByte[:lt])
}
```



## [845/87. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231205103501160.png" alt="image-20231205103501160" style="zoom:80%;" />

> 1. 自然而然的想到了最长回文子串, 从中心扩散
>    - 只不过是O(n^2), 时间复杂度太高了
>
> 2. 选择一次遍历, 记录当前的状态, 是持平,上升,还是下降
>    - 此题目有三种状态, 注意这三种状态的转义
>    - 不要只想着bool值来记录, 多一种状态也不是不行哈
>    - 多多注意状态转移
>    - 注意left的指针式right还是right-1

```go
func longestMountain(arr []int) int {
	state := 0 // 0 持平, 1 上升, 2 下降
	left := 0
	res := 0

	for right := 1; right < len(arr); right++ {
		if state == 1 { // 正在上坡
			if arr[right] > arr[right-1] { // 还在上坡
				continue
			} else if arr[right] < arr[right-1] { // 正在下坡,要记录一次
				state = 2
				res = max(res, right-left+1)
			} else { // 持平了
				state = 0
			}
		} else if state == 2 { // 正在下坡
			if arr[right] < arr[right-1] { // 还在下坡
				res = max(res, right-left+1)
			} else if arr[right] > arr[right-1] { //开始上坡
				left = right - 1 // 左指针移动
				state = 1
			} else {
				state = 0
			}
		} else { // 持平无效
			if arr[right] > arr[right-1] {
				left = right - 1 // 左指针移动
				state = 1
			} else { // 左指针移动
				left = right
			}
		}
	}
	return res
}
```





## [849/88. 到最近的人的最大距离](https://leetcode.cn/problems/maximize-distance-to-closest-person/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231206104233202.png" alt="image-20231206104233202" style="zoom:80%;" />

> 其实就是双指针
>
> - 注意左边界与右边界就ok啦
> - 还是老方法, left确定, right循环

```go
func maxDistToClosest(seats []int) int {
	res := 0
	left := -1

	for right := 0; right < len(seats); right++ {
		if seats[right] == 0 {
			continue
		} else {
			if left == -1 { // 最左端
				res = max(res, right)
			} else {
				res = max(res, (right-left)/2) // 中间的
			}
			left = right // 更新边界
		}
	}
	res = max(res, len(seats)-left-1) // 最右端

	return res
}
```









# 二分

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230714164859822.png" alt="image-20230714164859822" style="zoom:67%;" />

> log 复杂度 应该想到堆(优先队列) (不如二分)
>
> 这个题目可以归结到寻找第k小(大)元素问题，思路可以总结如下：取两个数组中的第k/2个元素进行比较，如果数组1的元素小于数组2的元素，则说明数组1中的前k/2个元素不可能成为第k个元素的候选，所以将数组1中的前k/2个元素去掉，组成新数组和数组2求第k-k/2小的元素，因为我们把前k/2个元素去掉了，所以相应的k值也应该减小。另外就是注意处理一些边界条件问题，比如某一个数组可能为空或者k为1的情况。
>
> 1. 在findK里面, 保证nums1的长度永远是小于nums2的, 这样对于空调见得判断以及后续判断更简单
> 2. 求中位数, 要分别判断奇偶数, 使用+1, 可以保证两个除以2得到相同的结果, 这样奇偶数可以使用一样的语句了
> 3. i, j := min(k/2, l1)-1, min(k/2, l2)-1, 保证一个数组特别短的时候, k/2不越界
> 4. 下标从0开始, 第几小从1开始的! 做好转换

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	l1, l2 := len(nums1), len(nums2)
	left, right := (l1+l2+1)/2, (l1+l2+2)/2
	return 0.5 * float64(findK(nums1, nums2, left)+findK(nums1, nums2, right))

}

func min(i, j int) int {
	if i < j {
		return i
	}
	return j
}

func findK(nums1, nums2 []int, k int) int {
	l1, l2 := len(nums1), len(nums2)
	if l1 > l2 {
		return findK(nums2, nums1, k)
	}
	if l1 == 0 {
		return nums2[k-1]
	}
	if k == 1 {
		return min(nums1[0], nums2[0])
	}

	i, j := min(k/2, l1)-1, min(k/2, l2)-1
	if nums1[i] < nums2[j] {
		return findK(nums1[i+1:], nums2, k-i-1)
	} else {
		return findK(nums1, nums2[j+1:], k-j-1)
	}
}
```

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230716134237578.png" alt="image-20230716134237578" style="zoom:67%;" />

> 在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 -1−1 变短：
>
> - 若向内 移动短板 ，水槽的短板 min(h[i], h[j]) 可能变大，因此下个水槽的面积 可能增大 。
> - 若向内 移动长板 ，水槽的短板 min(h[i], h[j]) 不变或变小，因此下个水槽的面积 一定变小 。
>
> *S*(*i*,*j*)=*m**i**n*(*h*[*i*],*h*[*j*])×(*j*−*i*)
>
> 面积是由短板决定的!!!!!!!!!!!!!!!!!

```go
func maxArea(height []int) int {
	left, right := 0, len(height)-1
	res := (len(height) - 1) * min(height[left], height[right])

	idx := 0
	for left != right {
		idx += 1
		if height[left] < height[right] {
			left += 1
			res = max(res, (len(height)-1-idx)*min(height[left], height[right]))
		} else {
			right -= 1
			res = max(res, (len(height)-1-idx)*min(height[left], height[right]))
		}
	}
	return res
}
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230716142846376.png" alt="image-20230716142846376" style="zoom:67%;" />

> 排序 + 双指针
>
> 时间复杂度：O(N^2)，其中 N 是数组 nums 的长度。
>
> 空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 \nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums的副本并进行排序，空间复杂度为O(N)。
>
> 
>
> 在first的每一次循环中
>
> - second从first加一开始
> - third从n-1开始, 一直向左, 因为second增加, 所以third慢慢减小

```go
func threeSum(nums []int) [][]int {
	n := len(nums)
	sort.Ints(nums)
	ans := make([][]int, 0)

	// 枚举 a
	for first := 0; first < n; first++ {
		// 需要和上一次枚举的数不相同
		if first > 0 && nums[first] == nums[first - 1] {
			continue
		}
		// c 对应的指针初始指向数组的最右端
		third := n - 1
		target := -1 * nums[first]
		// 枚举 b
		for second := first + 1; second < n; second++ {
			// 需要和上一次枚举的数不相同
			if second > first + 1 && nums[second] == nums[second - 1] {
				continue
			}
			// 需要保证 b 的指针在 c 的指针的左侧
			for second < third && nums[second] + nums[third] > target {
				third--
			}
			// 如果指针重合，随着 b 后续的增加
			// 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
			if second == third {
				break
			}
			if nums[second] + nums[third] == target {
				ans = append(ans, []int{nums[first], nums[second], nums[third]})
			}
		}
	}
	return ans
}
```

## [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230716145605051.png" alt="image-20230716145605051" style="zoom:67%;" />

> 三个数, 先排序, 固定a, 移动b和c
>
> 这样的话呢, 与target比较, 来决定移动b还是c
>
> 从而实现复杂度$O(N^2)$

```go
func threeSumClosest(nums []int, target int) int {
	sort.Ints(nums)
	n, best := len(nums), math.MaxInt32

	// 根据差值的绝对值来更新答案
	update := func(cur int) {
		if abs(cur-target) < abs(best-target) {
			best = cur
		}
	}

	// 枚举 a
	for i := 0; i < n; i++ {
		// 保证和上一次枚举的元素不相等
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		// 使用双指针枚举 b 和 c
		j, k := i+1, n-1
		for j < k {
			sum := nums[i] + nums[j] + nums[k]
			// 如果和为 target 直接返回答案
			if sum == target {
				return target
			}
			update(sum)
			if sum > target {
				// 如果和大于 target，移动 c 对应的指针到下一个不相等的元素
				k -= 1 // 至少要剪一次
				for j < k && nums[k] == nums[k+1] {
					k--
				}
			} else {
				// 如果和小于 target，移动 b 对应的指针到下一个不相等的元素
				j += 1
				for j < k && nums[j] == nums[j-1] {
					j++
				}
			}
		}
	}
	return best
}
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230716153237546.png" alt="image-20230716153237546" style="zoom:67%;" />

> 与三数之和一样的, 多一层循环而已
>
> 缺点是a+b+c+d可能溢出
>
> 多做一些剪枝操作 很快 判断相等continue很重要
>
> 
>
> 只有最内层的两个是在for循环里两端向内对齐的, 外层的都是for

```go
func fourSum(nums []int, target int) [][]int {
	var res [][]int
	sort.Ints(nums)
	n := len(nums)

	for a := 0; a < n; a++ {
		if a > 0 && nums[a] == nums[a-1] {
			continue
		}
		for b := a + 1; b < n; b++ {
			if b > a+1 && nums[b] == nums[b-1] {
				continue
			}
			c := b + 1
			d := n - 1
			for c < d {
				sum := nums[d] + nums[c] - target + nums[b] + nums[a]
				if sum > 0 {
					// 剪枝操作
					if nums[d]-nums[c] < sum {
						break
					}
					d--
					for c < d && nums[d] == nums[d+1] {
						d--
					}
				} else if sum < 0 {
					if nums[c]-nums[d] > sum {
						break
					}
					c++
					for c < d && nums[c] == nums[c-1] {
						c++
					}
				} else {
					res = append(res, []int{nums[a], nums[b], nums[c], nums[d]})
					c++
					d--
					for c < d && nums[c] == nums[c-1] {
						c++
					}
					for c < d && nums[d] == nums[d+1] {
						d--
					}
				}
			}
		}
	}
	return res
}
```

## [35. 模板 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230717170127544.png" alt="image-20230717170127544" style="zoom:67%;" />

> 二分查找的模板

```go
// bisect_left
l, r := 0, len(nums)
for l < r {
    mid := l + (r-l)/2
    if nums[mid] < target {
        l = mid + 1
    } else {
        r = mid
    }
}
return l(r)

// bisect_right
l, r := 0, len(nums)
for l < r {
	mid := l + (r-l)/2
	if nums[mid] <= target {
		l = mid + 1
	} else {
		r = mid
	}
}
return r
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230717171118005.png" alt="image-20230717171118005" style="zoom:67%;" />

> 与35一样, 二分查找的左插和右插
>
> 注意边界条件

```go
func searchRange(nums []int, target int) []int {
	if len(nums) == 0 {
		return []int{-1, -1}
	}
	res := []int{0, 0}

	//left
	l, r := 0, len(nums)
	for l < r {
		mid := l + (r-l)/2
		if nums[mid] < target {
			l = mid + 1
		} else {
			r = mid
		}
	}
	// 左边的边界条件, 不能在最右边
	if l == len(nums) || nums[l] != target {
		res[0] = -1
	} else {
		res[0] = l
	}

	// right
	l, r = 0, len(nums)
	for l < r {
		mid := l + (r-l)/2
		if nums[mid] <= target {
			l = mid + 1
		} else {
			r = mid
		}
	}
	// 右边的边界条件, 不能在最左边
	if l == 0 || nums[l-1] != target {
		res[1] = -1
	} else {
		res[1] = l - 1
	}
	return res
}
```

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230718104116159.png" alt="image-20230718104116159" style="zoom:67%;" />

> 光想着找旋转中心来做下标映射了
>
> 直接分而治之不就ok了吗??????
>
> 
>
> 边界条件比较复杂, 多多思考, 谨慎

```go
func search(nums []int, target int) int {
	// 找到分界点, 默认分界点在最后面, 即数组有序
	k := len(nums) - 1
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] > nums[i+1] {
			k = i
			break
		}
	}

	// binary
	binary := func(nums []int) int {
		l, r := 0, len(nums)
		for l < r {
			mid := l + (r-l)/2
			if nums[mid] < target {
				l = mid + 1
			} else {
				r = mid
			}
		}
		if l == len(nums) || nums[l] != target {
			return -1
		}
		return l
	}

	// 对两个部分进行
	if res := binary(nums[:k+1]); res != -1 {
		return res
	}
	if res := binary(nums[k+1:]); res != -1 {
		return k + res + 1
	}
	return -1
}
```

> 查找过程是ON 是不行的
>
> - 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
> - 判断顺序区间还是乱序区间，只需要对比 left 和 right 是否是顺序对即可，left <= right，顺序区间，否则乱序区间。
> - 每次二分都会至少存在一个顺序区间
> - 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. 

```go
func search(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := (right-left)/2 + left
		// 直接在mid找到了
		if nums[mid] == target {
			return mid
		}
		// 前半部分有序
		if nums[mid] >= nums[left] {
			// 在前半部分
			if nums[mid] > target && target >= nums[left] {
				right = mid - 1
			} else {
				// 不在前半部分
				left = mid + 1
			}
		} else {
			// 后半部分有序
			// 在 / 不在
			if nums[mid] < target && target <= nums[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}
	return -1
}
```







## [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230722163605658.png" alt="image-20230722163605658" style="zoom:67%;" />

> 继续分而治之

```go
func search(nums []int, target int) bool {
	// 找到分界点, 默认分界点在最后面, 即数组有序
	k := len(nums) - 1
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] > nums[i+1] {
			k = i
			break
		}
	}

	// binary search left
	binary := func(nums []int) bool {
		l, r := 0, len(nums)
		for l < r {
			mid := l + (r-l)/2
			if nums[mid] == target {
				return true
			}
			if nums[mid] < target {
				l = mid + 1
			} else {
				r = mid
			}
		}
		if l == len(nums) || nums[l] != target {
			return false
		}
		return true
	}

	// 对两个部分进行
	return binary(nums[:k+1]) || binary(nums[k+1:])
}
```

> logn的方法
>
> 这个数组里面是有重复的哈
>
> 所以某些边界条件是要改变的
>
> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230725122305621.png" alt="image-20230725122305621" style="zoom:50%;" />
>
> 最坏ON真的没有必要了, fk

```go
func search(nums []int, target int) bool {
	n := len(nums)
	if n == 0 {
		return false
	}
	if n == 1 {
		return nums[0] == target
	}
	l, r := 0, n-1
	for l <= r {
		mid := (l + r) / 2
		if nums[mid] == target {
			return true
		}
		if nums[l] == nums[mid] && nums[mid] == nums[r] {
			// 向里缩一下
			l++
			r--
		} else if nums[l] <= nums[mid] {
			// 前半部分有序的, 判断在不在前半部分里面
			if nums[l] <= target && target < nums[mid] {
				r = mid - 1
			} else {
				l = mid + 1
			}
		} else {
			// 后半部分有序的, 判断在不在后半部分
			if nums[mid] < target && target <= nums[n-1] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return false
}
```



## [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230721084915444.png" alt="image-20230721084915444" style="zoom:67%;" />

> 就是做一个下标映射的二分查找呗

```go
func searchMatrix(matrix [][]int, target int) bool {
    switchPos := func(idx, n, m int) (int, int) {
		return idx / m, idx - idx/m*m
	}
    
	n, m := len(matrix), len(matrix[0])
	low, high := 0, n*m-1
	for low < high {
		mid := low + (high-low)/2
		mid_n, mid_m := switchPos(mid, n, m)
		if matrix[mid_n][mid_m] < target {
			low = mid + 1
		} else {
			high = mid
		}
	}
	res_n, res_m := switchPos(high, n, m)
	return matrix[res_n][res_m] == target
}
```



## [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230725123037347.png" alt="image-20230725123037347" style="zoom:67%;" />

> 也是要求 ologn才可以
>
> 当然是一直二分啦
>
> 
>
> 对于查找插入类的二分,之前的模板很好用
>
> 但是对于这种要一直访问求值的二分, r=len-1 才更好使
>
> 但是我就是要坚持原来的写法, 必须如此(也是完全可以的)

```go
func min(i, j int) int {
	if i < j {
		return i
	}
	return j
}

func findMin(nums []int) int {
	res := math.MaxInt
	l, r := 0, len(nums)

	for l < r {
		mid := l + (r-l)/2
		// 左半部有序
		if nums[mid] > nums[l] {
			res = min(res, nums[l])
			l = mid + 1
		} else if nums[mid] <= nums[r-1] {
            // 为什么是==, 因为r-1和mid可能重合
			res = min(res, nums[mid])
			r = mid
		}
	}
	return res
}
```



## [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230725123918687.png" alt="image-20230725123918687" style="zoom:67%;" />

> 就是有重复元素了呗
>
> 开干
>
> - mid 与 l
> - mid 与 r-1

```go
func findMin(nums []int) int {
	res := math.MaxInt
	l, r := 0, len(nums)

	for l < r {
		mid := l + (r-l)/2
		// 三个部分相同
		if nums[l] == nums[mid] && nums[mid] == nums[r-1] {
			l, r = l+1, r-1
			res = min(res, nums[mid])
		} else if nums[l] <= nums[mid] {
			// 左半部分有序
			res = min(res, nums[l])
			l = mid + 1
		} else if nums[mid] <= nums[r-1] {
			res = min(res, nums[mid])
			r = mid
		}
	}
	return res
}
```



## [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726161244543.png" alt="image-20230726161244543" style="zoom:67%;" />

> 一次遍历, 可以这样遍历
>
> 当然也可以直接寻找最大值(最大值一定是峰值)

```go
func findPeakElement(nums []int) int {
	if len(nums) == 1 {
		return 0
	}

	if nums[0] > nums[1] {
		return 0
	}

	if nums[len(nums)-1] > nums[len(nums)-2] {
		return len(nums) - 1
	}

	for i := 1; i < len(nums)-1; i++ {
		if nums[i] > nums[i-1] && nums[i] > nums[i+1] {
			return i
		}
	}
	return len(nums) - 1
}
```

> 迭代爬坡, 哦哦哦哦哦

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726162002989.png" alt="image-20230726162002989" style="zoom:67%;" />

```go
func findPeakElement(nums []int) int {
	l := len(nums)
	idx := rand.Intn(l)

	get := func(idx int) int {
		if idx < 0 || idx >= l {
			return math.MinInt
		}
		return nums[idx]
	}

	for !(get(idx) > get(idx+1) && get(idx) > get(idx-1)) {
		if get(idx) < get(idx+1) {
			idx++
		} else {
			idx--
		}
	}
	return idx
}
```

> 二分的迭代爬坡, 牛蛙牛蛙
>
> 不要递归, 要二分查找的写法
>
> - 依旧坚持最初始的写法

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726162949090.png" alt="image-20230726162949090" style="zoom:67%;" />

```go
func findPeakElement(nums []int) int {
	n := len(nums)
	get := func(idx int) int {
		if idx < 0 || idx >= n {
			return math.MinInt
		}
		return nums[idx]
	}

	l, r := 0, n

	for l < r {
		// 获取一个中间节点
		mid := l + (r-l)/2
		if get(mid) > get(mid+1) && get(mid) > get(mid-1) {
			return mid
		}
		if get(mid) < get(mid+1) {
			l = mid + 1
		} else {
			r = mid
		}
	}
	return l
}
```



## [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806224243372.png" alt="image-20230806224243372" style="zoom:67%;" />

> 对于每一行进行二分查找呗

```go
func searchMatrix(matrix [][]int, target int) bool {
	binarySearch := func(nums []int) bool {
		l, r := 0, len(nums)
		for l < r {
			mid := l + (r-l)/2
			if nums[mid] < target {
				l = mid + 1
			} else {
				r = mid
			}
		}
		return l < len(nums) && nums[l] == target
	}

	for i := 0; i < len(matrix); i++ {
		if binarySearch(matrix[i]) {
			return true
		}
	}
	return false
}
```

> <img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230806225411927.png" alt="image-20230806225411927" style="zoom:67%;" />
>
> 这样一次就可以排除一行或者一列了

```go
func searchMatrix(matrix [][]int, target int) bool {
	m, n := len(matrix), len(matrix[0])
	i, j := 0, n-1
	for i < m && j >= 0 {
		if matrix[i][j] == target {
			return true
		} else if matrix[i][j] < target {
			i += 1
		} else {
			j -= 1
		}
	}
	return false
}
```



## [852/89. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231207104648045.png" alt="image-20231207104648045" style="zoom:80%;" />

> 显而易见, 直接二分
>
> - l,r均在数组中
> - 判断条件 l<r =>返回时l==r
> - l=mid+1, r=mid =>对应整数int的除法

```go
func peakIndexInMountainArray(arr []int) int {
	left, right := 1, len(arr)-2
	for left < right {
		mid := left + (right-left)/2
		if arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1] {
			return mid
		} else if arr[mid] < arr[mid+1] {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return left
}
```

还可以有更简单的二分 => 利用的就是最终`l==r`

```go
func peakIndexInMountainArray(arr []int) int {
	left, right := 0, len(arr)-1
	for left < right {
		mid := left + (right-left)/2
		if arr[mid] < arr[mid+1] {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return left
}
```



> 还可以直接使用sort.Search
>
> - 返回最小的满足条件的地方
> - 使用的也是二分法

```go
return sort.Search(len(arr)-1, func(i int) bool {
	return arr[i] > arr[i+1]
})
```





# 排序

## [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230719142035972.png" alt="image-20230719142035972" style="zoom:67%;" />

> 先排序, 之后再合并区间
>
> 先排序, 再进行n-1次排序
>
> 只需要根据第一个元素排序就行, 第二个不影响

```go
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })
	res := make([][]int, 0)

	l, r := intervals[0][0], intervals[0][1]
	for i := 0; i < len(intervals); i++ {
		if intervals[i][0] > r {
			res = append(res, []int{l, r})
			l, r = intervals[i][0], intervals[i][1]
		} else {
			if intervals[i][1] > r {
				r = intervals[i][1]
			}
		}
	}

	// emmmmm 最后剩下的不能丢
	res = append(res, []int{l, r})
	return res
}
```

## [57. 插入区间](https://leetcode.cn/problems/insert-interval/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230719143858821.png" alt="image-20230719143858821" style="zoom:67%;" />

> 可以直接append sort 再合并区间
>
> 只是那样的话复杂度超过$O(N)$了
>
> 这道题目是可以使用O(N)的解法来做的
>
> 
>
> 要点就是要认真分析多种情况, 别有遗漏

```go
func insert(intervals [][]int, newInterval []int) [][]int {
	l, r := newInterval[0], newInterval[1]
	res := make([][]int, 0)

	// true 代表还没有入res
	flag := true
	for i := 0; i < len(intervals); i++ {

		if intervals[i][0] >= l && intervals[i][1] <= r {
			// 完全在里面
		} else if intervals[i][0] <= l && intervals[i][1] >= r {
			// 完全包裹New
			l, r = intervals[i][0], intervals[i][1]
		} else if intervals[i][0] <= l && intervals[i][1] >= l && intervals[i][1] <= r {
			// 左端点相交
			l = intervals[i][0]
		} else if intervals[i][0] >= l && intervals[i][0] <= r && intervals[i][1] >= r {
			// 右端点香蕉
			r = intervals[i][1]
		} else if intervals[i][1] < l {
			// 还没到达左端点
			res = append(res, intervals[i])
		} else if flag && intervals[i][0] > r {
			// 超过右端点
			res = append(res, []int{l, r})
			res = append(res, intervals[i])
			flag = false
		} else {
			res = append(res, intervals[i])
		}
	}

	if flag {
		res = append(res, []int{l, r})
	}
	return res
}
```



## [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230722162547062.png" alt="image-20230722162547062" style="zoom:67%;" />

> $O(M+N)$ 有点难度
>
> 从尾部开始放入!!!!!!!!!!!!!!!!!!!!!
>
> woc!!!!!!!!!!!!!!!!!
>
> 66666!!!!!!!!!!!!!!!!!!

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	idx := m + n - 1
	m, n = m-1, n-1
	for ; idx > 0; idx-- {
		if m >= 0 && n >= 0 {
			if nums1[m] > nums2[n] {
				nums1[idx] = nums1[m]
				m--
			} else {
				nums1[idx] = nums2[n]
				n--
			}
		} else if m >= 0 {
			nums1[idx] = nums1[m]
			m--
		} else {
			nums1[idx] = nums2[n]
			n--
		}
	}
}
```



## [179. 最大数](https://leetcode.cn/problems/largest-number/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230726001806696.png" alt="image-20230726001806696" style="zoom:67%;" />

> 一看就是自定义排序 + 连接
>
> 别想的太复杂哈
>
> - 但是自定义排序可不能直接比较字符串
> - 要看两个数字相拼接之后哪个更大
> - 注意全都是数字0

```go
func largestNumber(nums []int) string {
	sort.Slice(nums, func(i, j int) bool {
		x, y := nums[i], nums[j]
		sx, sy := 10, 10
		for sx <= x {
			sx *= 10
		}
		for sy <= y {
			sy *= 10
		}
		return sy*x+y > sx*y+x
	})

	if nums[0] == 0 {
		return "0"
	}

	res := ""
	for _, num := range nums {
		res += strconv.Itoa(num)
	}
	return res
}
```



## [164. 最大间距](https://leetcode.cn/problems/maximum-gap/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230728014712726.png" alt="image-20230728014712726" style="zoom:67%;" />

> 肯定是和排序有关的啊
>
> 您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。 => 桶排序/基数排序呗

```go
func maximumGap(nums []int) int {
	if len(nums) < 2 {
		return 0
	}
	sort.Ints(nums)
	res := -1
	for i := 1; i < len(nums); i++ {
		res = max(res, abs(nums[i]-nums[i-1]))
	}
	return res
}
```

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803104418074.png" alt="image-20230803104418074" style="zoom:67%;" />

> 1. 直接sort
> 2. 使用heap, 优先队列
> 3. 快速排序

```go
func sortArrayHeap(nums []int) {
	n := len(nums)
	for i := n / 2; i >= 0; i-- {
		heapify(nums, n, i)
	}
}

func heapify(nums []int, n, i int) {
	largest, left, right := i, 2*i+1, 2*i+2
	if left < n && nums[left] > nums[largest] {
		largest = left
	}
	if right < n && nums[right] > nums[largest] {
		largest = right
	}
	// 向下恢复最大堆
	if largest != i {
		nums[i], nums[largest] = nums[largest], nums[i]
		heapify(nums, n, largest)
	}
}

func findKthLargest(nums []int, k int) int {
	heapSize := len(nums)
	sortArrayHeap(nums)
	for i := len(nums) - 1; i >= len(nums)-k+1; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapSize--
		heapify(nums, heapSize, 0)
	}
	return nums[0]
}
```

> 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，
> 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。
>
> 时间复杂度 最差n2, 随机化的话, 是n

```go
func quickPartition(nums []int, start, end, target int) {
	randNum := rand.Intn(end-start+1) + start
	base := nums[randNum]
	nums[start], nums[randNum] = nums[randNum], nums[start]
	idx := start
	// 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素
	// 交换到index + 1位置，index++，使得最终index前面的元素都比base大。
	for i := start + 1; i <= end; i++ {
		if nums[i] >= base {
			nums[idx+1], nums[i] = nums[i], nums[idx+1]
			idx += 1
		}
	}
	nums[start], nums[idx] = nums[idx], nums[start]

	// 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，
	// 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。
	if idx < target {
		quickPartition(nums, idx+1, end, target)
	} else if idx > target {
		quickPartition(nums, start, idx-1, target)
	}
}

func findKthLargest(nums []int, k int) int {
	quickPartition(nums, 0, len(nums)-1, k-1)
	return nums[k-1]
}

```



## [853/89. 车队](https://leetcode.cn/problems/car-fleet/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231207112004593.png" alt="image-20231207112004593" style="zoom: 67%;" />

> 就是一句话, 后面的车不能比前面的车到达早, 早的话就只能一同到达
>
> 创建struct, 并排序就ok啦

```go
func carFleet(target int, position []int, speed []int) int {
	// 保存车辆数据并排序
	type tuple struct{ pos, speed float64 }
	car := make([]tuple, 0)
	for i := 0; i < len(position); i++ {
		car = append(car, tuple{pos: float64(position[i]), speed: float64(speed[i])})
	}
	sort.Slice(car, func(i, j int) bool {
		return car[i].pos > car[j].pos
	})

	// 计算有多少种到达时间
	res := 0
	var pre float64 = -1e10 // 前一个的到达时间
	for i := 0; i < len(car); i++ {
		time := (float64(target) - car[i].pos) / car[i].speed
		if time > pre {
			pre = time
			res++
		}
	}
	return res
}
```









# 数组模拟

## [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230719113245705.png" alt="image-20230719113245705" style="zoom:67%;" />

> 设定4个边界
>
> 每次循环式四个方向都走一遍, 走一个边减少一个边界
>
> 每次走一个边减少一个边界, 边界路过就终止了
>
> 这样的话, 编码简单, 不需要弯弯绕绕

```go
func spiralOrder(matrix [][]int) []int {
	// m, n
	m, n := len(matrix), len(matrix[0])
	// 四个边界
	u, d, l, r := 0, m-1, 0, n-1
	res := make([]int, 0, m*n)

	for {
		// 向右
		for i := l; i <= r; i++ {
			res = append(res, matrix[u][i])
		}
		u += 1
		if u > d {
			break
		}

		// 向下
		for i := u; i <= d; i++ {
			res = append(res, matrix[i][r])
		}
		r -= 1
		if l > r {
			break
		}

		//向左
		for i := r; i >= l; i-- {
			res = append(res, matrix[d][i])
		}
		d -= 1
		if d < u {
			break
		}

		//向上
		for i := d; i >= u; i-- {
			res = append(res, matrix[i][l])
		}
		l += 1
		if l > r {
			break
		}

	}
	return res

}
```

## [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230719115427040.png" alt="image-20230719115427040" style="zoom:67%;" />

> 一样的写法

```go
func generateMatrix(n int) [][]int {
	// 四个边界
	u, d, l, r := 0, n-1, 0, n-1
	// 创建数组
	res := make([][]int, n, n)
	for i := 0; i < n; i++ {
		res[i] = make([]int, n, n)
	}
	idx := 1

	for {
		// 向右
		for i := l; i <= r; i++ {
			res[u][i] = idx
			idx += 1
		}
		u += 1
		if u > d {
			break
		}

		// 向下
		for i := u; i <= d; i++ {
			res[i][r] = idx
			idx += 1
		}
		r -= 1
		if l > r {
			break
		}

		//向左
		for i := r; i >= l; i-- {
			res[d][i] = idx
			idx += 1
		}
		d -= 1
		if d < u {
			break
		}

		//向上
		for i := d; i >= u; i-- {
			res[i][l] = idx
			idx += 1
		}
		l += 1
		if l > r {
			break
		}

	}
	return res
}
```

## [66. 加一](https://leetcode.cn/problems/plus-one/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230719225133636.png" alt="image-20230719225133636" style="zoom:67%;" />

> so easy 
>
> go的append 还挺好玩

```go
func plusOne(digits []int) []int {
	jw := 1 // 最开始代表要加的1
	for i := len(digits) - 1; i >= 0; i-- {
		t := jw + digits[i]
		digits[i], jw = t%10, t/10
	}
	if jw == 0 {
		return digits
	} else {
		return append([]int{jw}, digits...)
	}
}
```

## [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230721105446635.png" alt="image-20230721105446635" style="zoom:67%;" />

> 原地算法
>
> 如果这行有0, 则这行的第一个设置为0
>
> 如果这列有, 则这列的第一个设置为0
>
> 第0行, 第0列单独一个变量保存 Good

```go
func setZeroes(matrix [][]int) {
	// 第0行 列需不需要置0
	zeroRow, zeroColumn := false, false
	for i := 0; i < len(matrix); i++ {
		if matrix[i][0] == 0 {
			zeroColumn = true
		}
	}
	for j := 0; j < len(matrix[0]); j++ {
		if matrix[0][j] == 0 {
			zeroRow = true
		}
	}
    
	for i := 1; i < len(matrix); i++ {
		for j := 1; j < len(matrix[0]); j++ {
			if matrix[i][j] == 0 {
				matrix[i][0] = 0
				matrix[0][j] = 0
			}
		}
	}

	for i := 1; i < len(matrix); i++ {
		for j := 1; j < len(matrix[0]); j++ {
			if matrix[i][0] == 0 || matrix[0][j] == 0 {
				matrix[i][j] = 0
			}
		}
	}

	if zeroRow {
		for i := 0; i < len(matrix[0]); i++ {
			matrix[0][i] = 0
		}
	}
	if zeroColumn {
		for i := 0; i < len(matrix); i++ {
			matrix[i][0] = 0
		}
	}
}
```





# 扫描线

## [218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20230803112232327.png" alt="image-20230803112232327" style="zoom:67%;" />

> 扫描线问题, 还是得写啊
>
> 扫描线的核心在于 **将不规则的形状按照水平或者垂直的方式，划分成若干个规则的矩形。**
>
> - 这道题难点在于理解。天际线这一情景十分抽象，我们不如将这道题转化为另一个情景--物种统治问题：假设[lefti, righti, heighti] 存放的是某一物种的出现、灭绝时间和能力值，某一时刻存活的能力值最高的物种统治世界。要求得每次统治的开始时间和统治物种的能力值。
> - 这样就很容易思考了：首先用（time，+/-ability）来记录每个物种的出现、灭绝时间（正负号用于区分是出现时间还是灭绝时间），并按照时间顺序排序。维持一个大顶堆，当一个物种出现时，将对应的能力值丢入大顶堆；当一个物种灭绝时，将对应的能力从大顶堆中拿出。这样，大顶堆就时刻维持着当前统治的物种的能力值。进而求得每次统治的开始时间和对应能力值。
> - 默认存在一个能力值为0，存在时间无限的憨憨物种兜底。
> - 由于优先队列的 remove 操作需要先经过 O(n) 的复杂度进行查找，再通过 O(log⁡n) 的复杂度进行删除。因此整个 remove 操作的复杂度是 O(n) 的，这导致了我们算法整体复杂度为 O(n2)
>
> - 时间复杂度：O(nlog⁡n)
> - 空间复杂度：O(n)
>
> 出现水平高度差的变化时, 进行结果的保存!!!!!!!!!!!!

```go
type PriorityQueue []int

func (pq PriorityQueue) Len() int            { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool  { return pq[i] > pq[j] }
func (pq PriorityQueue) Swap(i, j int)       { pq[i], pq[j] = pq[j], pq[i] }
func (pq *PriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(int)) }
func (pq *PriorityQueue) Pop() interface{}   { *pq = (*pq)[0 : pq.Len()-1]; return nil }

func getSkyline(buildings [][]int) [][]int {
	var res, ps [][]int // 返回的结果

	// 存入这些数据 flag -1 代表左端点
	for _, build := range buildings {
		ps = append(ps, []int{build[0], build[2], -1}, []int{build[1], build[2], 1})
	}

	/**
	 * 先严格按照横坐标进行「从小到大」排序
	 * 对于某个横坐标而言，可能会同时出现多个点，应当按照如下规则进行处理：
	 * 1. 优先处理左端点，再处理右端点
	 * 2. 如果同样都是左端点，则按照高度「从大到小」进行处理（将高度增加到优先队列中）
	 * 3. 如果同样都是右端点，则按照高度「从小到大」进行处理（将高度从优先队列中删掉）
	 */
	sort.Slice(ps, func(i, j int) bool {
		a, b := ps[i], ps[j]
		if a[0] != b[0] { // 横坐标不等, 直接排序
			return a[0] < b[0]
		} else if a[2] != b[2] { // 先左后右
			return a[2] < b[2]
		}
		if a[2] == -1 { // 都是左, 或者都是右
			return a[1] > b[1]
		} else {
			return a[1] < b[1]
		}
	})

	// 记录进行了删除操作的高度，以及删除次数
	m := make(map[int]int)
	pq := &PriorityQueue{0}
	prev := 0

	for _, p := range ps {
		point, height, flag := p[0], p[1], p[2]
		if flag == -1 { // 处理一个左端点, 存入一个height
			heap.Push(pq, height)
		} else { // 右端点 删除次数+1
			m[height] = m[height] + 1
		}

		for pq.Len() != 0 {
			peek := (*pq)[0]
			if m[peek] != 0 {
				m[peek] -= 1
				heap.Pop(pq)
			} else {
				break
			}
		}

		cur := (*pq)[0]
		if cur != prev {
			res = append(res, []int{point, cur})
			prev = cur
		}
	}
	return res
}
```





# 普通矩阵问题



## [840/86. 矩阵中的幻方](https://leetcode.cn/problems/magic-squares-in-grid/)

<img src="./%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F.assets/image-20231204235414943.png" alt="image-20231204235414943" style="zoom:80%;" />

> 直接暴力模拟, 不要害怕哈
>
> - 可以使用bitmap进行3x3来进行计数哈哈哈, 应该比map来模拟set方便

```go
func numMagicSquaresInside(grid [][]int) int {
	res := 0
	if len(grid) < 3 || len(grid[0]) < 3 {
		return res
	}

	pos := [][]int{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}

	for i := 1; i < len(grid)-1; i++ {
		for j := 1; j < len(grid[1])-1; j++ {
			bit := 0
			for _, p := range pos {
				bit |= 1 << grid[i+p[0]][j+p[1]]
			}
			r1 := grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]
			r2 := grid[i][j-1] + grid[i][j] + grid[i][j+1]
			r3 := grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]

			c1 := grid[i-1][j-1] + grid[i][j-1] + grid[i+1][j-1]
			c2 := grid[i-1][j] + grid[i][j] + grid[i+1][j]
			c3 := grid[i-1][j+1] + grid[i][j+1] + grid[i+1][j+1]

			d1 := grid[i-1][j-1] + grid[i][j] + grid[i+1][j+1]
			d2 := grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1]

			if r1 == r2 && r2 == r3 && c1 == c2 && c2 == c3 && d1 == d2 && bit == 1022 {
				res++
			}
		}
	}
	return res
}
```









































































